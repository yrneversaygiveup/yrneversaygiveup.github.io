<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>常用函数接口</title>
      <link href="/posts/4055e175.html"/>
      <url>/posts/4055e175.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/c789aff2d6e9">Cg标准函数库 - 简书 (jianshu.com)</a></p><div class="table-container"><table><thead><tr><th style="text-align:center">常用函数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">o.pos=UnityObjectToClipPos(v.vertex);</td><td style="text-align:center">将模型空间顶点坐标转换到裁剪空间坐标</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">saturate(x)</td><td style="text-align:center">返回x处于0-1之间的值，超出范围的全部取0和1</td></tr><tr><td style="text-align:center">dot(x,y)</td><td style="text-align:center">点积</td></tr><tr><td style="text-align:center">pow(x,y)</td><td style="text-align:center">$x^y$</td></tr><tr><td style="text-align:center">normalize(x)</td><td style="text-align:center">归一化</td></tr><tr><td style="text-align:center">z=reflect(x,y)</td><td style="text-align:center">法线为y,入射方向为x,返回出生方向z</td></tr><tr><td style="text-align:center"></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">常用变量</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">UNITY_LIGHTMODEL_AMBIENT</td><td style="text-align:center">当前环境光</td></tr><tr><td style="text-align:center">_WorldSpaceLightPos0</td><td style="text-align:center">世界空间下的光源位置</td></tr><tr><td style="text-align:center">_WorldSpaceCameraPos</td><td style="text-align:center">世界空间下的摄像机的位置</td></tr><tr><td style="text-align:center">_LightColor0</td><td style="text-align:center">光源颜色</td></tr><tr><td style="text-align:center">unity_WorldToObject</td><td style="text-align:center">变换矩阵：左乘该矩阵：将世界坐标转换为模型坐标。右乘则相反，将模型坐标转换为世界坐标</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
            <tag> unity </tag>
            
            <tag> hlsl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.1 单张纹理</title>
      <link href="/posts/15a2f545.html"/>
      <url>/posts/15a2f545.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用纹理来代替物体的漫反射颜色"><a href="#使用纹理来代替物体的漫反射颜色" class="headerlink" title="使用纹理来代替物体的漫反射颜色"></a>使用纹理来代替物体的漫反射颜色</h1><p>代码如下：</p><pre><code class="lang-c#">// Upgrade NOTE: replaced &#39;_Object2World&#39; with &#39;unity_ObjectToWorld&#39;// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;Shader &quot;Unity Shaders Book/Chapter 7/Single Texture&quot; &#123;    Properties &#123;        _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)        //添加纹理属性        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Specular (&quot;Specular&quot;, Color) = (1, 1, 1, 1)        _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20    &#125;    SubShader &#123;                Pass &#123;             Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #include &quot;Lighting.cginc&quot;            fixed4 _Color;            //纹理属性            sampler2D _MainTex;            //纹理平铺属性            float4 _MainTex_ST;            fixed4 _Specular;            float _Gloss;            struct a2v &#123;                float4 vertex : POSITION;                float3 normal : NORMAL;                //输入的纹理坐标                float4 texcoord : TEXCOORD0;            &#125;;            struct v2f &#123;                float4 pos : SV_POSITION;                float3 worldNormal : TEXCOORD0;                float3 worldPos : TEXCOORD1;                //用来输出到片元着色器的纹理坐标                float2 uv : TEXCOORD2;            &#125;;            v2f vert(a2v v) &#123;                v2f o;                o.pos = UnityObjectToClipPos(v.vertex);                o.worldNormal = UnityObjectToWorldNormal(v.normal);                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;                //xy是tilling,zw是offset                o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;                // Or just call the built-in function//                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);                return o;            &#125;            fixed4 frag(v2f i) : SV_Target &#123;                fixed3 worldNormal = normalize(i.worldNormal);                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));                // Use the texture to sample the diffuse color                //使用tex2D采样纹理坐标所指向的纹理颜色                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;                fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir));                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));                fixed3 halfDir = normalize(worldLightDir + viewDir);                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss);                return fixed4(ambient + diffuse + specular, 1.0);            &#125;            ENDCG        &#125;    &#125;     FallBack &quot;Specular&quot;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第七章：基础纹理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纹理属性</title>
      <link href="/posts/fae112f7.html"/>
      <url>/posts/fae112f7.html</url>
      
        <content type="html"><![CDATA[<h1 id="纹理属性"><a href="#纹理属性" class="headerlink" title="纹理属性"></a>纹理属性</h1><p><img src="https://gitee.com/yurain11/drawing-bed/raw/master/img/image-20230407101219447.png" alt="image-20230407101219447"></p><ul><li><p>Wrap Mode:决定平铺属性</p><ul><li>repeat:重复</li><li>Clamp：截取边界值</li></ul></li><li><p>Filter Mode:决定了变换拉伸后使用哪种滤波模式(放大放小的图片质量)</p><p><a href="https://docs.unity.cn/cn/2020.3/ScriptReference/FilterMode.html">FilterMode - Unity 脚本 API</a></p><p>效果依次提升，但是性能消耗也变大</p><ul><li>Point</li><li>Biliner</li><li><p>Trilinear（区别于biliner的是否开启mipmaping）</p></li><li><p>mipmaping技术</p><p>用于纹理缩小，需要使用一张多级渐远纹理，多占用33%空间</p><p><a href="https://docs.unity3d.com/2021.3/Documentation/Manual/texture-mipmaps.html">统一 - 手动：米普贴图 (unity3d.com)</a></p></li></ul><p>详细原理参考图形学教程。</p></li><li><p>max size:不能超出的最大像素值</p></li><li>format:决定unity内部用那种方式储存该纹理</li></ul>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第七章：基础纹理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 纹理 </tag>
            
            <tag> shaderLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.2 凹凸纹理</title>
      <link href="/posts/529bf6c6.html"/>
      <url>/posts/529bf6c6.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用法线"><a href="#使用法线" class="headerlink" title="使用法线"></a>使用法线</h1><ul><li><p>高度图</p><p>存储的是强度值，用来表现模型表面的海拔高度，颜色越浅越向外凸，颜色越深则相反，好处是非常直观，缺点是计算复杂</p><p>想要和法线一样使用：纹理类型设置为normal map,勾选create from Grayscale</p><ul><li>Bumpiness:控制凹凸程度</li><li>Filtering:法线的纹理平滑或者尖锐</li></ul></li><li><p>法线纹理</p><ul><li><p>法线的范围在[-1,1],像素范围在[0,1],所以在制作法线贴图时，需要把法线映射到像素，在使用法线贴图时，需要把像素映射回法线。</p></li><li><p>模型空间的法线纹理：即模型空间的表面法线</p><p>优点：简单直观，可以提供平滑的边界。</p><p>缺点：自由度低</p></li><li><p>切线空间的法线纹理：每个顶点的法线方向为z轴，x轴是切线方向，y轴则是两个方向叉积的方向（副切线）</p><p>优点：可以用于其他模型做效果，可以移动uv制作效果，可以重复用uv,可以压缩。</p><p>缺点：边缘处容易有缝合迹象</p></li></ul></li></ul><h2 id="在切线空间下计算：效率高"><a href="#在切线空间下计算：效率高" class="headerlink" title="在切线空间下计算：效率高"></a>在切线空间下计算：效率高</h2><pre><code class="lang-c#">// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;Shader &quot;Unity Shaders Book/Chapter 7/Normal Map In Tangent Space&quot; &#123;    Properties &#123;        _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;        //导入法线纹理        _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125;        //设置法线强度        _BumpScale (&quot;Bump Scale&quot;, Float) = 1.0        _Specular (&quot;Specular&quot;, Color) = (1, 1, 1, 1)        _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20    &#125;    SubShader &#123;        Pass &#123;             Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #include &quot;Lighting.cginc&quot;            fixed4 _Color;            sampler2D _MainTex;            float4 _MainTex_ST;            //法线和法线强度            sampler2D _BumpMap;            float4 _BumpMap_ST;            float _BumpScale;            fixed4 _Specular;            float _Gloss;            struct a2v &#123;                float4 vertex : POSITION;                float3 normal : NORMAL;                //需要传入切线，用来计算，第四个参数用来确定切线的方向                float4 tangent : TANGENT;                float4 texcoord : TEXCOORD0;            &#125;;            struct v2f &#123;                float4 pos : SV_POSITION;                float4 uv : TEXCOORD0;                float3 lightDir: TEXCOORD1;                float3 viewDir : TEXCOORD2;            &#125;;            // Unity doesn&#39;t support the &#39;inverse&#39; function in native shader            // so we write one by our own            // Note: this function is just a demonstration, not too confident on the math or the speed            // Reference: http://answers.unity3d.com/questions/218333/shader-inversefloat4x4-function.html            float4x4 inverse(float4x4 input) &#123;                #define minor(a,b,c) determinant(float3x3(input.a, input.b, input.c))                float4x4 cofactors = float4x4(                     minor(_22_23_24, _32_33_34, _42_43_44),                     -minor(_21_23_24, _31_33_34, _41_43_44),                     minor(_21_22_24, _31_32_34, _41_42_44),                    -minor(_21_22_23, _31_32_33, _41_42_43),                    -minor(_12_13_14, _32_33_34, _42_43_44),                     minor(_11_13_14, _31_33_34, _41_43_44),                    -minor(_11_12_14, _31_32_34, _41_42_44),                     minor(_11_12_13, _31_32_33, _41_42_43),                     minor(_12_13_14, _22_23_24, _42_43_44),                    -minor(_11_13_14, _21_23_24, _41_43_44),                     minor(_11_12_14, _21_22_24, _41_42_44),                    -minor(_11_12_13, _21_22_23, _41_42_43),                    -minor(_12_13_14, _22_23_24, _32_33_34),                     minor(_11_13_14, _21_23_24, _31_33_34),                    -minor(_11_12_14, _21_22_24, _31_32_34),                     minor(_11_12_13, _21_22_23, _31_32_33)                );                #undef minor                return transpose(cofactors) / determinant(input);            &#125;            v2f vert(a2v v) &#123;                v2f o;                o.pos = UnityObjectToClipPos(v.vertex);                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;                o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;                ///                /// Note that the code below can handle both uniform and non-uniform scales                ///                // Construct a matrix that transforms a point/vector from tangent space to world space                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);                  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);                  fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w;                 /*                float4x4 tangentToWorld = float4x4(worldTangent.x, worldBinormal.x, worldNormal.x, 0.0,                                                   worldTangent.y, worldBinormal.y, worldNormal.y, 0.0,                                                   worldTangent.z, worldBinormal.z, worldNormal.z, 0.0,                                                   0.0, 0.0, 0.0, 1.0);                // The matrix that transforms from world space to tangent space is inverse of tangentToWorld                float3x3 worldToTangent = inverse(tangentToWorld);                */                //wToT = the inverse of tToW = the transpose of tToW as long as tToW is an orthogonal matrix.                float3x3 worldToTangent = float3x3(worldTangent, worldBinormal, worldNormal);                //TANGENT_SPACE_ROTATION;列出这个宏，我们可以直接使用rotation,即worldToTangent                // Transform the light and view dir from world space to tangent space                o.lightDir = mul(worldToTangent, WorldSpaceLightDir(v.vertex));                o.viewDir = mul(worldToTangent, WorldSpaceViewDir(v.vertex));                ///                /// Note that the code below can only handle uniform scales, not including non-uniform scales                ///                 // Compute the binormal//                float3 binormal = cross( normalize(v.normal), normalize(v.tangent.xyz) ) * v.tangent.w;//                // Construct a matrix which transform vectors from object space to tangent space//                float3x3 rotation = float3x3(v.tangent.xyz, binormal, v.normal);                // Or just use the built-in macro//                TANGENT_SPACE_ROTATION;//                //                // Transform the light direction from object space to tangent space//                o.lightDir = mul(rotation, normalize(ObjSpaceLightDir(v.vertex))).xyz;//                // Transform the view direction from object space to tangent space//                o.viewDir = mul(rotation, normalize(ObjSpaceViewDir(v.vertex))).xyz;                return o;            &#125;            fixed4 frag(v2f i) : SV_Target &#123;                                fixed3 tangentLightDir = normalize(i.lightDir);                fixed3 tangentViewDir = normalize(i.viewDir);                // Get the texel in the normal map                //更据存在uv.zw上的纹理坐标进行采样法线                fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw);                fixed3 tangentNormal;                // If the texture is not marked as &quot;Normal map&quot;//                tangentNormal.xy = (packedNormal.xy * 2 - 1) * _BumpScale;//                tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));                // Or mark the texture as &quot;Normal map&quot;, and use the built-in funciton                //需要映射回[-1,1]                tangentNormal = UnpackNormal(packedNormal);                //z由xy决定，所以xy一定要变成最终结果后再求z                tangentNormal.xy *= _BumpScale;                tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;                fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(tangentNormal, tangentLightDir));                fixed3 halfDir = normalize(tangentLightDir + tangentViewDir);                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(tangentNormal, halfDir)), _Gloss);                return fixed4(ambient + diffuse + specular, 1.0);            &#125;            ENDCG        &#125;    &#125;     FallBack &quot;Specular&quot;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第七章：基础纹理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.4 遮罩纹理</title>
      <link href="/posts/79c6506a.html"/>
      <url>/posts/79c6506a.html</url>
      
        <content type="html"><![CDATA[<h1 id="遮罩纹理"><a href="#遮罩纹理" class="headerlink" title="遮罩纹理"></a>遮罩纹理</h1><p>用来保护某些区域避免被修改</p><p>原理：使用其中的通道与原图相乘，如果通道值为0，则不受影响。</p><p>比如说想要控制高光，就制作一张高光的遮罩图，通过与原图相乘，来控制该遮罩图在原图上的影响大小，用来调出想要的高光。</p><pre><code class="lang-c">// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;Shader &quot;Unity Shaders Book/Chapter 7/Mask Texture&quot; &#123;    Properties &#123;        _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;        _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125;        _BumpScale(&quot;Bump Scale&quot;, Float) = 1.0        //高光遮罩        _SpecularMask (&quot;Specular Mask&quot;, 2D) = &quot;white&quot; &#123;&#125;        _SpecularScale (&quot;Specular Scale&quot;, Float) = 1.0        _Specular (&quot;Specular&quot;, Color) = (1, 1, 1, 1)        _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20    &#125;    SubShader &#123;        Pass &#123;             Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #include &quot;Lighting.cginc&quot;            fixed4 _Color;            sampler2D _MainTex;            float4 _MainTex_ST;            sampler2D _BumpMap;            float _BumpScale;            sampler2D _SpecularMask;            float _SpecularScale;            fixed4 _Specular;            float _Gloss;            struct a2v &#123;                float4 vertex : POSITION;                float3 normal : NORMAL;                float4 tangent : TANGENT;                float4 texcoord : TEXCOORD0;            &#125;;            struct v2f &#123;                float4 pos : SV_POSITION;                float2 uv : TEXCOORD0;                float3 lightDir: TEXCOORD1;                float3 viewDir : TEXCOORD2;            &#125;;            v2f vert(a2v v) &#123;                v2f o;                o.pos = UnityObjectToClipPos(v.vertex);                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;                //使用了宏                TANGENT_SPACE_ROTATION;                o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;                o.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz;                return o;            &#125;            fixed4 frag(v2f i) : SV_Target &#123;                 fixed3 tangentLightDir = normalize(i.lightDir);                fixed3 tangentViewDir = normalize(i.viewDir);                fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uv));                tangentNormal.xy *= _BumpScale;                tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;                fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(tangentNormal, tangentLightDir));                 fixed3 halfDir = normalize(tangentLightDir + tangentViewDir);                 // Get the mask value                 fixed specularMask = tex2D(_SpecularMask, i.uv).r * _SpecularScale;                 // Compute specular term with the specular mask                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(tangentNormal, halfDir)), _Gloss) * specularMask;                return fixed4(ambient + diffuse + specular, 1.0);            &#125;            ENDCG        &#125;    &#125;     FallBack &quot;Specular&quot;&#125;</code></pre><p>重复利用遮罩：把不同属性存储在图片不同通道中，已到达更好的效果。</p>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第七章：基础纹理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.3 渐变纹理</title>
      <link href="/posts/ac8870a9.html"/>
      <url>/posts/ac8870a9.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用渐变纹理控制漫反射光照"><a href="#使用渐变纹理控制漫反射光照" class="headerlink" title="使用渐变纹理控制漫反射光照"></a>使用渐变纹理控制漫反射光照</h1><pre><code class="lang-c#">// Upgrade NOTE: replaced &#39;_Object2World&#39; with &#39;unity_ObjectToWorld&#39;// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;Shader &quot;Unity Shaders Book/Chapter 7/Ramp Texture&quot; &#123;    Properties &#123;        _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)        _RampTex (&quot;Ramp Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Specular (&quot;Specular&quot;, Color) = (1, 1, 1, 1)        _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20    &#125;    SubShader &#123;        Pass &#123;             Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #include &quot;Lighting.cginc&quot;            fixed4 _Color;            sampler2D _RampTex;            float4 _RampTex_ST;            fixed4 _Specular;            float _Gloss;            struct a2v &#123;                float4 vertex : POSITION;                float3 normal : NORMAL;                float4 texcoord : TEXCOORD0;            &#125;;            struct v2f &#123;                float4 pos : SV_POSITION;                float3 worldNormal : TEXCOORD0;                float3 worldPos : TEXCOORD1;                float2 uv : TEXCOORD2;            &#125;;            v2f vert(a2v v) &#123;                v2f o;                o.pos = UnityObjectToClipPos(v.vertex);                o.worldNormal = UnityObjectToWorldNormal(v.normal);                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;                o.uv = TRANSFORM_TEX(v.texcoord, _RampTex);                return o;            &#125;            fixed4 frag(v2f i) : SV_Target &#123;                fixed3 worldNormal = normalize(i.worldNormal);                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;                // Use the texture to sample the diffuse color                fixed halfLambert  = 0.5 * dot(worldNormal, worldLightDir) + 0.5;                //斜线采样                fixed3 diffuseColor = tex2D(_RampTex, fixed2(halfLambert, halfLambert)).rgb * _Color.rgb;                fixed3 diffuse = _LightColor0.rgb * diffuseColor;                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));                fixed3 halfDir = normalize(worldLightDir + viewDir);                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss);                return fixed4(ambient + diffuse + specular, 1.0);            &#125;            ENDCG        &#125;    &#125;     FallBack &quot;Specular&quot;&#125;</code></pre><p>对一个渐变纹理采样即可。</p>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第七章：基础纹理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Debug</title>
      <link href="/posts/ad6468a3.html"/>
      <url>/posts/ad6468a3.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用假彩色图像"><a href="#使用假彩色图像" class="headerlink" title="使用假彩色图像"></a>使用假彩色图像</h1><p>主要思想：把需要调试的变量映射到0-1，作为颜色输出到屏幕</p><p><code>c#</code></p><h1 id="使用VS"><a href="#使用VS" class="headerlink" title="使用VS"></a>使用VS</h1><p>Graphics Debugger</p><h1 id="帧调试器（Frame-Debugger）"><a href="#帧调试器（Frame-Debugger）" class="headerlink" title="帧调试器（Frame Debugger）"></a>帧调试器（Frame Debugger）</h1><p>window-frame debugger</p>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第五章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity内置文件和变量</title>
      <link href="/posts/e7a93b90.html"/>
      <url>/posts/e7a93b90.html</url>
      
        <content type="html"><![CDATA[<h1 id="内置文件"><a href="#内置文件" class="headerlink" title="内置文件"></a>内置文件</h1><ul><li>后缀为.cginc</li><li>路径：安装位置/Data/CGIncludes</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">文件名</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">UnityCG.cginc</td><td style="text-align:center">包含最常使用的帮助函数、宏和结构体</td></tr><tr><td style="text-align:center">UnityShaderVariables.cginc</td><td style="text-align:center">编译时会自动包含，包括许多内置的全局变量，比如UNITY_MATRIX_MVP</td></tr><tr><td style="text-align:center">Lighting.cginc</td><td style="text-align:center">包含内置光照模型，编写surface shader会自动包含</td></tr><tr><td style="text-align:center">HLSLSupport.cginc</td><td style="text-align:center">编译时会自动包含，生命很多跨平台的宏和定义</td></tr></tbody></table></div><ul><li><p>UnityCG.cginc常用结构体</p><p>|     名称     |      描述      |              包含的变量              |<br>| :—————: | :——————: | :—————————————————: |<br>| appdata_base | 顶点着色器输入 |    顶点位置，法线，第一组纹理坐标    |<br>| appdata_tan  | 顶点着色器输入 | 顶点位置，法线，切线，第一组纹理坐标 |<br>| appdata_full | 顶点着色器输入 |  顶点位置，法线，切线，四组纹理坐标  |<br>| appdata_img  | 顶点着色器输入 |       顶点位置，第一组纹理坐标       |<br>|   v2f_img    | 顶点着色器输出 |   裁剪空间位置，texcoord0纹理坐标    |</p></li><li><p>UnityCG.cginc常用帮助函数</p><p>|                    函数名                    |                             描述                             |<br>| :—————————————————————: | :—————————————————————————————: |<br>| float3 （Unity）WorldSpaceViewDir(float4 v)  | 输入：模型空间顶点位置。输出：世界空间下该点到摄像机的观察方向 |<br>|       float3 ObjSpaceViewDir(float4 v)       | 输入：模型空间顶点位置。输出：模型空间下该点到摄像机的观察方向 |<br>| float3 （Unity）WorldSpaceLightDir(float4 v) | <strong>只能用于向前渲染（forward）</strong>，输入模型空间的顶点位置，返回世界空间该点到光源的光照方向，未归一化。 |<br>|      float3 ObjSpaceLightDir(float4 v)       | <strong>只能用于向前渲染（forward）</strong>，输入模型空间的顶点位置，返回模型空间该点到光源的光照方向，未归一化。 |<br>| float3 UnityObjectToWorldNormal(float3 norm) |             把法线方向从模型空间转换到世界空间中             |<br>|   float3 UnityObjectToWorldDir(float3 dir)   |             把方向向量从模型空间变换到世界空间中             |<br>|   float3 UnityWorldToObjectDir(float3 dir)   |             把方向向量从世界空间变换到模型空间中             |</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第五章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shader编写规范</title>
      <link href="/posts/786c70b1.html"/>
      <url>/posts/786c70b1.html</url>
      
        <content type="html"><![CDATA[<h1 id="float-half-fixed"><a href="#float-half-fixed" class="headerlink" title="float half fixed"></a>float half fixed</h1><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">精度</th></tr></thead><tbody><tr><td style="text-align:center">float</td><td style="text-align:center">最高精度浮点值，32位</td></tr><tr><td style="text-align:center">half</td><td style="text-align:center">中等精度，16位，-60000~+60000</td></tr><tr><td style="text-align:center">fixed</td><td style="text-align:center">最低精度，11位，-2.0~+2.0</td></tr></tbody></table></div><ul><li>不同的值请选择不同的精度类型，减少内存的消耗</li></ul><h1 id="避免不必要的计算"><a href="#避免不必要的计算" class="headerlink" title="避免不必要的计算"></a>避免不必要的计算</h1><ul><li>不同的Shader Target,不同的着色器阶段，可以使用的临时寄存器和指令数目是不同的。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">#pragma target 2.0（Direct3D  Shader Model 2.0）</td><td style="text-align:center">默认等级，不支持顶点纹理采样，不支持显示的LOD纹理采样</td></tr><tr><td style="text-align:center">#pragma target 3.0（Direct3D  Shader Model 3.0）</td><td style="text-align:center">支持顶点纹理采样</td></tr><tr><td style="text-align:center">#pragma target 4.0（Direct3D  Shader Model 4.0）</td><td style="text-align:center">支持几何着色器</td></tr><tr><td style="text-align:center">#pragma target 5.0（Direct3D  Shader Model 5  .0）</td></tr></tbody></table></div><h1 id="慎用分支和循环语句"><a href="#慎用分支和循环语句" class="headerlink" title="慎用分支和循环语句"></a>慎用分支和循环语句</h1><ul><li><p>不鼓励在shader中使用流程控制语句，会降低GPU并行处理操作</p></li><li><p>如果大量使用，要把该使用尽量放在流水线上端</p></li><li>分支判断中的条件变量最好是常数，即不发生变化</li><li>每个分支包含的操作指令少</li><li>分支的嵌套数少</li></ul><h1 id="不要除以0"><a href="#不要除以0" class="headerlink" title="不要除以0"></a>不要除以0</h1><ul><li>对除数可能为0的情况，强制截取到非0</li><li>使用很小的浮点数保证分母大于0</li></ul>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第五章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UnityShader结构</title>
      <link href="/posts/8204bd5a.html"/>
      <url>/posts/8204bd5a.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一个代码学习"><a href="#第一个代码学习" class="headerlink" title="第一个代码学习"></a>第一个代码学习</h1><pre><code class="lang-c#">// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;//开头引号内存放路径Shader &quot;MyShader/BaseShader&quot;&#123;    //属性栏    Properties&#123;        //声明一个Color类型属性        _Color(&quot;Color Tint&quot;,Color)=(1.0,1.0,1.0,1.0)    &#125;    SubShader&#123;        Pass&#123;            CGPROGRAM            //告诉unity定义了vert和frag：顶点和片元着色器            #pragma vertex vert            #pragma fragment frag            //在Cg代码中需要定义一个与属性名称和类型都匹配的变量            fixed4 _Color;            //定义一个结构体来定义顶点着色器的输出            struct a2v&#123;                //存放顶点位置                float4 vertex:POSITION;                //存放法线                float3 normal:NORMAL;                //用第0个纹理填充texcoord                float4 texcoord:TEXCOORD0;            &#125;;            //使用一个结构体定义顶点着色器的输出            struct v2f&#123;                //把裁剪空间下的顶点坐标存放在pos                float4 pos:SV_POSITION;                //color用来存放颜色信息                fixed3 color:COLOR0;            &#125;;            //输入v:POSITION输入顶点位置，返回一个float4的变量            //SV_POSITION：表示输出的是裁剪空间的坐标,返回一个v2f的结构体            v2f vert(a2v v) &#123;            //定义需要传出的变量            v2f o;            o.pos=UnityObjectToClipPos(v.vertex);            o.color=v.normal*0.5+fixed3(0.5,0.5,0.5);            return o;        &#125;            //返回一个fixed4变量，SV_Target把输出的颜色输出到渲染目标中            fixed4 frag(v2f i) : SV_Target&#123;                fixed3 c=i.color;                c*=_Color.rgb;                return fixed4(c,1.0);            &#125;        ENDCG    &#125;    &#125;&#125;</code></pre><ul><li><p>属性表</p><p>| ShaderLab属性类型 |     Cg变量类型      |<br>| :———————-: | :————————-: |<br>|   Color,Vector    | float4,half4,fixed4 |<br>|    Range,Float    |  float,half,fixed   |<br>|        2D         |      sampler2D      |<br>|       Cube        |     samplerCube     |<br>|        3D         |      sampler3D      |</p></li><li><p>Cg变量前可能有uniform，可以省略</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第五章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity光源类型</title>
      <link href="/posts/6f2d2584.html"/>
      <url>/posts/6f2d2584.html</url>
      
        <content type="html"><![CDATA[<h1 id="光源"><a href="#光源" class="headerlink" title="光源"></a>光源</h1><ul><li>平行光</li><li>点光源</li><li>聚光灯d</li></ul><pre><code class="lang-c#">// Upgrade NOTE: replaced &#39;_LightMatrix0&#39; with &#39;unity_WorldToLight&#39;// Upgrade NOTE: replaced &#39;_Object2World&#39; with &#39;unity_ObjectToWorld&#39;// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;Shader &quot;Unity Shaders Book/Chapter 9/Forward Rendering&quot; &#123;    Properties &#123;        _Diffuse (&quot;Diffuse&quot;, Color) = (1, 1, 1, 1)        _Specular (&quot;Specular&quot;, Color) = (1, 1, 1, 1)        _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20    &#125;    SubShader &#123;        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;        Pass &#123;            // Pass for ambient light &amp; first pixel light (directional light)            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;            CGPROGRAM            // Apparently need to add this declaration             #pragma multi_compile_fwdbase                #pragma vertex vert            #pragma fragment frag            #include &quot;Lighting.cginc&quot;            fixed4 _Diffuse;            fixed4 _Specular;            float _Gloss;            struct a2v &#123;                float4 vertex : POSITION;                float3 normal : NORMAL;            &#125;;            struct v2f &#123;                float4 pos : SV_POSITION;                float3 worldNormal : TEXCOORD0;                float3 worldPos : TEXCOORD1;            &#125;;            v2f vert(a2v v) &#123;                v2f o;                o.pos = UnityObjectToClipPos(v.vertex);                o.worldNormal = UnityObjectToWorldNormal(v.normal);                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;                return o;            &#125;            fixed4 frag(v2f i) : SV_Target &#123;                fixed3 worldNormal = normalize(i.worldNormal);                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;                 fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * max(0, dot(worldNormal, worldLightDir));                 fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);                 fixed3 halfDir = normalize(worldLightDir + viewDir);                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss);                fixed atten = 1.0;                return fixed4(ambient + (diffuse + specular) * atten, 1.0);            &#125;            ENDCG        &#125;        Pass &#123;            // Pass for other pixel lights            Tags &#123; &quot;LightMode&quot;=&quot;ForwardAdd&quot; &#125;            Blend One One            CGPROGRAM            // Apparently need to add this declaration            #pragma multi_compile_fwdadd            #pragma vertex vert            #pragma fragment frag            #include &quot;Lighting.cginc&quot;            #include &quot;AutoLight.cginc&quot;            fixed4 _Diffuse;            fixed4 _Specular;            float _Gloss;            struct a2v &#123;                float4 vertex : POSITION;                float3 normal : NORMAL;            &#125;;            struct v2f &#123;                float4 pos : SV_POSITION;                float3 worldNormal : TEXCOORD0;                float3 worldPos : TEXCOORD1;            &#125;;            v2f vert(a2v v) &#123;                v2f o;                o.pos = UnityObjectToClipPos(v.vertex);                o.worldNormal = UnityObjectToWorldNormal(v.normal);                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;                return o;            &#125;            fixed4 frag(v2f i) : SV_Target &#123;                fixed3 worldNormal = normalize(i.worldNormal);                //判断光源类型，如果是平行光，则，不是的则                #ifdef USING_DIRECTIONAL_LIGHT                    fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);                #else                    fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz - i.worldPos.xyz);                #endif                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * max(0, dot(worldNormal, worldLightDir));                fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);                fixed3 halfDir = normalize(worldLightDir + viewDir);                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss);                #ifdef USING_DIRECTIONAL_LIGHT                    fixed atten = 1.0;                #else                    #if defined (POINT)                    //转换到光源空间计算衰减                        float3 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, 1)).xyz;                        fixed atten = tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;                    #elif defined (SPOT)                        float4 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, 1));                        fixed atten = (lightCoord.z &gt; 0) * tex2D(_LightTexture0, lightCoord.xy / lightCoord.w + 0.5).w * tex2D(_LightTextureB0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;                    #else                        fixed atten = 1.0;                    #endif                #endif                return fixed4((diffuse + specular) * atten, 1.0);            &#125;            ENDCG        &#125;    &#125;    FallBack &quot;Specular&quot;&#125;</code></pre><p>unity处理点光源的顺序按照重要度排序，重要度取决于距离物体的远近，光源颜色，强度等。当物体不在光的范围内时则会不调用pass。渲染可以查看帧调试器frame Debugger</p><p><img src="https://gitee.com/yurain11/drawing-bed/raw/master/img/202304091424999.png" alt="image-20230409142450877"></p>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第九章：更复杂的光照 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
            <tag> unity </tag>
            
            <tag> 光照 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity渲染路径</title>
      <link href="/posts/4f764081.html"/>
      <url>/posts/4f764081.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是渲染路径（rendering-path）"><a href="#什么是渲染路径（rendering-path）" class="headerlink" title="什么是渲染路径（rendering path）"></a>什么是渲染路径（rendering path）</h1><ul><li><p>渲染路径决定了光照是如何应用到unityshader中。</p></li><li><p>一般一个项目只使用一种渲染路径：</p><p><img src="https://gitee.com/yurain11/drawing-bed/raw/master/img/202304091246220.png" alt="image-20230409121105424"></p><p>open Editor</p><p><img src="https://gitee.com/yurain11/drawing-bed/raw/master/img/202304091211206.png" alt="image-20230409121149042"></p><p>关闭use defaults即可设置</p></li><li><p>设置多个渲染路径</p><p>可以在不同相机中设置不同的渲染路径</p><p><img src="https://gitee.com/yurain11/drawing-bed/raw/master/img/202304091214244.png" alt="image-20230409121409169"></p></li><li><p>如果显卡不支持，unity会自动降一级渲染路径</p></li><li><p>|            标签名            |                             描述                             |<br>| :—————————————: | :—————————————————————————————: |<br>|            Always            |     不管使用哪种路径，该pass总是会被渲染，但不会计算光照     |<br>|         ForwardBase          | 用于向前渲染，会计算环境光，最重要的平行光，逐顶点/SH光源和Lightmaps |<br>|          ForwardAdd          |    向前渲染，会计算额外的逐像素光源，每个pass对应一个光源    |<br>|           Deferred           |                    延迟渲染，渲染G-buffer                    |<br>|         ShadowCaster         | 把物体的深度信息渲染到阴影纹理映射（shadowmap）或一张深度纹理中 |<br>|         PrepassBase          |        遗留的延迟渲染，会渲染法线和高光反射的指数部分        |<br>|         PrepassFinal         | 遗留的延迟渲染，通过合并纹理，光照，自发光来渲染最后得到的颜色 |<br>| Vertex,VertexLMRGBM,VertexLM |                      遗留的顶点照明渲染                      |</p></li></ul><h2 id="向前渲染路径（Foward-Rendering-Path）"><a href="#向前渲染路径（Foward-Rendering-Path）" class="headerlink" title="向前渲染路径（Foward Rendering Path）"></a>向前渲染路径（Foward Rendering Path）</h2><pre><code class="lang-tex">Pass&#123;    Tags&#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;|&quot;ForwardAdd&quot;&#125;&#125;</code></pre><p>渲染对象的渲染图元并计算两个缓冲区</p><ul><li>颜色缓冲区</li><li>深度缓冲区：决定是否可见</li><li>对于每个逐像素光照都需要单独计算pass,当物体受到多个逐像素光照时，就要计算多个pass,N(物体数量)*M（逐像素光照）</li><li>三种处理光照的方式：逐顶点处理，逐像素处理，球谐函数（SH）处理</li></ul><h3 id="unity渲染优先级"><a href="#unity渲染优先级" class="headerlink" title="unity渲染优先级"></a>unity渲染优先级</h3><ul><li><p>最亮的平行光按照逐像素处理</p></li><li><p>渲染模式为Not Important的使用逐顶点和SH渲染。</p></li><li><p>Important使用逐像素</p></li><li><p>在以上规则后逐像素光源数量小于Quailty Setting 中的Pixel Light Count,则会有更多光源以逐像素处理</p><p><img src="https://gitee.com/yurain11/drawing-bed/raw/master/img/202304091233770.png" alt="image-20230409123348674"></p></li></ul><h3 id="两种pass的标签和渲染设置以及常规光照计算"><a href="#两种pass的标签和渲染设置以及常规光照计算" class="headerlink" title="两种pass的标签和渲染设置以及常规光照计算"></a>两种pass的标签和渲染设置以及常规光照计算</h3><ul><li><pre><code class="lang-tex">#pragma multi_compile_fwdbase#pragma multi_compile_fwdadd只有为两个pass使用这两个编译指令，才可以在pass中得到正确的光照变量，比如光照衰减值。</code></pre></li><li><p>Base Pass可实现的光照效果：光照纹理，环境光，自发光，阴影（平行光阴影）</p></li><li><p>Add Pass默认没有阴影，可以使用#pragma multi_compile_fwdadd_fullshadows为点光源和聚光灯开启阴影。</p></li><li><p>Add Pass中需要开启混合模式，否则会覆盖,一般选择Blend One One</p></li></ul><h3 id="内置的光照变量和函数"><a href="#内置的光照变量和函数" class="headerlink" title="内置的光照变量和函数"></a>内置的光照变量和函数</h3><p>向前渲染可以使用的内置光照变量</p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">_LightColor0</td><td style="text-align:center">float4</td><td style="text-align:center">逐像素光源颜色</td></tr><tr><td style="text-align:center">_WorldSpaceLightPos0</td><td style="text-align:center">float4</td><td style="text-align:center">_WorldSpaceLightPos0.xyz是光源位置，如果是平行光,_WorldSpaceLightPos0.w为0,否则为1</td></tr><tr><td style="text-align:center">_LightMatrix0</td><td style="text-align:center">float4x4</td><td style="text-align:center">世界空间到光源空间的变换矩阵，可以用于采样cookie和光强衰减纹理</td></tr><tr><td style="text-align:center">unity_4LightPosX0,unity_4LightPosY0,unity_4LightPosZ0,</td><td style="text-align:center">float4</td><td style="text-align:center">仅用于base pass，前4个非重要点光源在世界空间的位置</td></tr><tr><td style="text-align:center">unity_4LightAtten0</td><td style="text-align:center">float4</td><td style="text-align:center">仅用于base pass，前4个非重要点光源的衰减因子</td></tr><tr><td style="text-align:center">unity_LightColor</td><td style="text-align:center">half4[4]</td><td style="text-align:center">仅用于base pass，前4个非重要点光源的颜色</td></tr></tbody></table></div><p>向前渲染的内置光照函数</p><div class="table-container"><table><thead><tr><th>函数名</th><th>描述</th></tr></thead><tbody><tr><td>float3 WorldSpaceLightDir(float4 v)</td><td>仅向前渲染，输入模型空间的顶点位置，返回世界空间中 点到光源的方向，未归一</td></tr><tr><td>float3 UnityWorldSpaceLightDir(float4 v)</td><td>仅向前渲染，输入世界空间的顶点位置，返回世界空间中 点到光源的方向，未归一</td></tr><tr><td>float3 ObjSpaceLightDir(float4 v)</td><td>仅向前渲染，输入模型空间的顶点位置，返回模型空间中 点到光源的方向，未归一</td></tr><tr><td>float3 Shade4PointLights(…)</td><td>仅向前渲染,计算4个点光源的光照。</td></tr></tbody></table></div><h2 id="延迟渲染路径（Deferred-Rendering-Path）"><a href="#延迟渲染路径（Deferred-Rendering-Path）" class="headerlink" title="延迟渲染路径（Deferred Rendering Path）"></a>延迟渲染路径（Deferred Rendering Path）</h2><p>unity 5.0后新的延迟渲染替代旧的延迟渲染</p><p>原理：包含两个pass</p><p>第一个pass：只执行一次，不进行光照计算，仅计算可见性，通过深度缓冲技术实现。如果可见，则将各类信息存入G缓冲当中。</p><p>第二个pass利用G缓冲的信息，进行真正的光照。</p><p>延迟渲染的效率不依赖场景的复杂度，而是与屏幕空间的大小有关。</p><h3 id="unity中的延迟渲染"><a href="#unity中的延迟渲染" class="headerlink" title="unity中的延迟渲染"></a>unity中的延迟渲染</h3><p>适合场景光源较多的情况，如果使用向前渲染会造成性能瓶颈。</p><p>每个光源都可以当做逐像素处理。</p><p>缺点：</p><ul><li>不支持真正的抗锯齿</li><li>不能处理半透明</li><li>对显卡有要求：支持MRT,Shader Mode3.0以上，深度渲染纹理和双面模板缓冲。</li></ul><p>默认的G缓冲区包含</p><ul><li>RT0,格式为ARGB32,RGB用于存储漫反射颜色，A通道未利用</li><li>RT1,格式为ARGB32,RGB用于存储高光反射颜色，A通道存放高光反射指数</li><li>RT2,格式为ARGB2101010,RGB存放法线，A未利用</li><li>RT3,格式为ARGB32（非HDR）或ARGBHalf(HDR)，用于存储自发光+lightmap+反射探针</li><li>深度缓冲和模板缓冲</li></ul><p>可使用的内置变量</p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">格式</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">_LightColor</td><td style="text-align:center">float4</td><td style="text-align:center">光源颜色</td></tr><tr><td style="text-align:center">_LightMatrix0</td><td style="text-align:center">float4x4</td><td style="text-align:center">世界空间到光源空间的变换矩阵，用于采样cookie和光照衰减纹理</td></tr></tbody></table></div><h2 id="顶点照明路径（Vertex-Lit-Rendering-Path）"><a href="#顶点照明路径（Vertex-Lit-Rendering-Path）" class="headerlink" title="顶点照明路径（Vertex Lit Rendering Path）"></a>顶点照明路径（Vertex Lit Rendering Path）</h2><p>unity 5.0后被抛弃</p><p>配置要求最少，性能最高，效果最差。P185</p>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第九章：更复杂的光照 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
            <tag> unity </tag>
            
            <tag> 渲染路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity光照衰减</title>
      <link href="/posts/93a5249d.html"/>
      <url>/posts/93a5249d.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用纹理作为插值表"><a href="#使用纹理作为插值表" class="headerlink" title="使用纹理作为插值表"></a>使用纹理作为插值表</h1><p>优点：采样即可，可以提升性能，适用于大部分场景。</p><p>缺点：</p><ul><li>需要预处理得到采样纹理，纹理大小会影响衰减的精度</li><li>不直观和不方便，无法使用其他数学公式来计算衰减。</li></ul><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>只关心对角线上的衰减值。</p><ul><li>先获得光源空间的位置，使用光源空间中顶点距离的平方采样，避开开方操作（理解：范围在0-1,平方的范围也在0-1）,使用.rr操作就是构建一二维数组,再使用UNITY_ATTEN_CHANNEL获得衰减纹理的分量值。</li></ul>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第九章：更复杂的光照 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
            <tag> unity </tag>
            
            <tag> 光照 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语义</title>
      <link href="/posts/92ba7da.html"/>
      <url>/posts/92ba7da.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是语义"><a href="#什么是语义" class="headerlink" title="什么是语义"></a>什么是语义</h1><ul><li>语义是赋给shader输入和输出的字符串，即语义可以让shader知道从哪读取数据，并把数据输入到哪。</li><li>语义出现的位置 不同，含义也不同。</li></ul><h1 id="系统数值语义"><a href="#系统数值语义" class="headerlink" title="系统数值语义"></a>系统数值语义</h1><ul><li>以SV开头</li><li>不可以被随便赋值：需要完成特定的目的</li></ul><h1 id="Unity支持的语义"><a href="#Unity支持的语义" class="headerlink" title="Unity支持的语义"></a>Unity支持的语义</h1><h2 id="a2v"><a href="#a2v" class="headerlink" title="a2v"></a>a2v</h2><div class="table-container"><table><thead><tr><th style="text-align:center">语义</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">POSITION</td><td style="text-align:center">模型空间的顶点位置，通常是float4类型</td></tr><tr><td style="text-align:center">NORMAL</td><td style="text-align:center">顶点法线，float3</td></tr><tr><td style="text-align:center">TANGENT</td><td style="text-align:center">顶点切线，float4</td></tr><tr><td style="text-align:center">TEXCOORDn</td><td style="text-align:center">该顶点的纹理坐标，通常是float2或者float4</td></tr><tr><td style="text-align:center">COLOR</td><td style="text-align:center">顶点颜色，fixed4或者float4</td></tr></tbody></table></div><h2 id="v2f"><a href="#v2f" class="headerlink" title="v2f"></a>v2f</h2><div class="table-container"><table><thead><tr><th style="text-align:center">语义</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">SV_POSITION</td><td style="text-align:center">裁剪空间的顶点坐标，必须被包含</td></tr><tr><td style="text-align:center">COLOR0</td><td style="text-align:center">输出第一组顶点颜色（不是必须）</td></tr><tr><td style="text-align:center">COLOR1</td><td style="text-align:center">输出第二组顶点颜色（不是必须）</td></tr><tr><td style="text-align:center">TEXCOOORD0-7</td><td style="text-align:center">输出纹理坐标，不是必须</td></tr></tbody></table></div><h2 id="OUT"><a href="#OUT" class="headerlink" title="OUT"></a>OUT</h2><div class="table-container"><table><thead><tr><th style="text-align:center">语义</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">SV_Target</td><td style="text-align:center">会将输出值存储到渲染目标中。</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第五章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>透明度混合</title>
      <link href="/posts/597910df.html"/>
      <url>/posts/597910df.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用Blend"><a href="#使用Blend" class="headerlink" title="使用Blend"></a>使用Blend</h1><div class="table-container"><table><thead><tr><th style="text-align:center">语义</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">Blend Off</td><td style="text-align:center">关闭混合</td></tr><tr><td style="text-align:center">Blend SrcFactor DstFactor</td><td style="text-align:center">开启混合，并设置混合因子。片元颜色乘以SrcFactor,缓存颜色乘以DstFactor,两者相加再存入颜色缓存中。</td></tr><tr><td style="text-align:center">Blend SrcFactor DstFactor，SrcFactorA DstFactorA</td><td style="text-align:center">使用不同因子混合透明通道</td></tr><tr><td style="text-align:center">BlendOp BlendOperation</td><td style="text-align:center">片元颜色和缓存颜色相加后使用BlendOperation进行其他操作</td></tr></tbody></table></div><pre><code class="lang-c#">// Upgrade NOTE: replaced &#39;_Object2World&#39; with &#39;unity_ObjectToWorld&#39;// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;Shader &quot;Unity Shaders Book/Chapter 8/Alpha Blend&quot; &#123;    Properties &#123;        _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;        _AlphaScale (&quot;Alpha Scale&quot;, Range(0, 1)) = 1    &#125;    SubShader &#123;        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;        Pass &#123;            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;            ZWrite Off            //            Blend SrcAlpha OneMinusSrcAlpha            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #include &quot;Lighting.cginc&quot;            fixed4 _Color;            sampler2D _MainTex;            float4 _MainTex_ST;            fixed _AlphaScale;            struct a2v &#123;                float4 vertex : POSITION;                float3 normal : NORMAL;                float4 texcoord : TEXCOORD0;            &#125;;            struct v2f &#123;                float4 pos : SV_POSITION;                float3 worldNormal : TEXCOORD0;                float3 worldPos : TEXCOORD1;                float2 uv : TEXCOORD2;            &#125;;            v2f vert(a2v v) &#123;                v2f o;                o.pos = UnityObjectToClipPos(v.vertex);                o.worldNormal = UnityObjectToWorldNormal(v.normal);                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);                return o;            &#125;            fixed4 frag(v2f i) : SV_Target &#123;                fixed3 worldNormal = normalize(i.worldNormal);                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));                fixed4 texColor = tex2D(_MainTex, i.uv);                fixed3 albedo = texColor.rgb * _Color.rgb;                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;                fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir));                //Alpha图层的大小调整                return fixed4(ambient + diffuse, texColor.a * _AlphaScale);            &#125;            ENDCG        &#125;    &#125;     FallBack &quot;Transparent/VertexLit&quot;&#125;</code></pre><p><a href="https://docs.unity.cn/cn/2020.2/Manual/SL-Blend.html">ShaderLab：混合 - Unity 手册</a></p>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第八章：透明效果 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
            <tag> unity </tag>
            
            <tag> 透明效果 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity阴影</title>
      <link href="/posts/c6377d6.html"/>
      <url>/posts/c6377d6.html</url>
      
        <content type="html"><![CDATA[<h1 id="阴影实现"><a href="#阴影实现" class="headerlink" title="阴影实现"></a>阴影实现</h1><ul><li><p>实时渲染中使用的Shadow Map：把摄像机与光源重合，阴影区域就是摄像机看不到的地方。</p></li><li><p>unity使用额外的Pass专门更新光源的阴影映射纹理，这个pass就是LightMode被设置未ShadowCaster的pass。该pass的渲染目标是阴影映射纹理。通过调用该pass先将摄像机摆放到光源位置，再将深度信息存入阴影映射纹理中。</p></li><li>该Pass会被优先执行</li></ul><h2 id="屏幕空间的阴影映射技术"><a href="#屏幕空间的阴影映射技术" class="headerlink" title="屏幕空间的阴影映射技术"></a>屏幕空间的阴影映射技术</h2><ol><li>调用LightMode为shadowcaster的pass得到阴影纹理映射和摄像机的深度纹理，根据这两张图来得到屏幕空间的阴影图（在摄像机的深度中但不在光源的深度中：可见的阴影）</li><li>接受阴影：采样结果和光照结果相乘</li><li>投射阴影：把该物体加入阴影映射纹理的计算中。</li></ol><pre><code class="lang-c#">Pass &#123;        Name &quot;ShadowCaster&quot;        Tags &#123; &quot;LightMode&quot; = &quot;ShadowCaster&quot; &#125;CGPROGRAM#pragma vertex vert#pragma fragment frag#pragma target 2.0#pragma multi_compile_shadowcaster#pragma multi_compile_instancing // allow instanced shadow pass for most of the shaders#include &quot;UnityCG.cginc&quot;struct v2f &#123;    V2F_SHADOW_CASTER;    UNITY_VERTEX_OUTPUT_STEREO&#125;;v2f vert( appdata_base v )&#123;    v2f o;    UNITY_SETUP_INSTANCE_ID(v);    UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);    TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)    return o;&#125;float4 frag( v2f i ) : SV_Target&#123;    SHADOW_CASTER_FRAGMENT(i)&#125;ENDCG    &#125;</code></pre><pre><code class="lang-c#">// Upgrade NOTE: replaced &#39;_LightMatrix0&#39; with &#39;unity_WorldToLight&#39;// Upgrade NOTE: replaced &#39;_Object2World&#39; with &#39;unity_ObjectToWorld&#39;// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;Shader &quot;Unity Shaders Book/Chapter 9/Shadow&quot; &#123;    Properties &#123;        _Diffuse (&quot;Diffuse&quot;, Color) = (1, 1, 1, 1)        _Specular (&quot;Specular&quot;, Color) = (1, 1, 1, 1)        _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20    &#125;    SubShader &#123;        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;        Pass &#123;            // Pass for ambient light &amp; first pixel light (directional light)            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;            CGPROGRAM            // Apparently need to add this declaration             #pragma multi_compile_fwdbase                #pragma vertex vert            #pragma fragment frag            // Need these files to get built-in macros            #include &quot;Lighting.cginc&quot;            //计算阴影的宏在这个文件中被定义            #include &quot;AutoLight.cginc&quot;            fixed4 _Diffuse;            fixed4 _Specular;            float _Gloss;            struct a2v &#123;                float4 vertex : POSITION;                float3 normal : NORMAL;            &#125;;            struct v2f &#123;                float4 pos : SV_POSITION;                float3 worldNormal : TEXCOORD0;                float3 worldPos : TEXCOORD1;                //声明一个用于阴影纹理采样的坐标，参数是下一个可用的插值寄存器的坐标（前面用了0和1）                SHADOW_COORDS(2)            &#125;;            v2f vert(a2v v) &#123;                 v2f o;                 o.pos = UnityObjectToClipPos(v.vertex);                 o.worldNormal = UnityObjectToWorldNormal(v.normal);                 o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;                 // Pass shadow coordinates to pixel shader计算声明的阴影纹理坐标                 TRANSFER_SHADOW(o);                 return o;            &#125;            fixed4 frag(v2f i) : SV_Target &#123;                fixed3 worldNormal = normalize(i.worldNormal);                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;                 fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * max(0, dot(worldNormal, worldLightDir));                 fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);                 fixed3 halfDir = normalize(worldLightDir + viewDir);                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss);                fixed atten = 1.0;                //计算阴影                fixed shadow = SHADOW_ATTENUATION(i);                //使用宏必须保证变量名相匹配：v.vertex,a.pos                return fixed4(ambient + (diffuse + specular) * atten * shadow, 1.0);            &#125;            ENDCG        &#125;        Pass &#123;            // Pass for other pixel lights            Tags &#123; &quot;LightMode&quot;=&quot;ForwardAdd&quot; &#125;            Blend One One            CGPROGRAM            // Apparently need to add this declaration            #pragma multi_compile_fwdadd            // Use the line below to add shadows for point and spot lights//            #pragma multi_compile_fwdadd_fullshadows            #pragma vertex vert            #pragma fragment frag            #include &quot;Lighting.cginc&quot;            #include &quot;AutoLight.cginc&quot;            fixed4 _Diffuse;            fixed4 _Specular;            float _Gloss;            struct a2v &#123;                float4 vertex : POSITION;                float3 normal : NORMAL;            &#125;;            struct v2f &#123;                float4 position : SV_POSITION;                float3 worldNormal : TEXCOORD0;                float3 worldPos : TEXCOORD1;            &#125;;            v2f vert(a2v v) &#123;                 v2f o;                 o.position = UnityObjectToClipPos(v.vertex);                 o.worldNormal = UnityObjectToWorldNormal(v.normal);                 o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;                 return o;            &#125;            fixed4 frag(v2f i) : SV_Target &#123;                fixed3 worldNormal = normalize(i.worldNormal);                #ifdef USING_DIRECTIONAL_LIGHT                    fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);                #else                    fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz - i.worldPos.xyz);                #endif                 fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * max(0, dot(worldNormal, worldLightDir));                 fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);                 fixed3 halfDir = normalize(worldLightDir + viewDir);                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss);                #ifdef USING_DIRECTIONAL_LIGHT                    fixed atten = 1.0;                #else                    float3 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, 1)).xyz;                    fixed atten = tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;                #endif                return fixed4((diffuse + specular) * atten, 1.0);            &#125;            ENDCG        &#125;    &#125;    FallBack &quot;Specular&quot;&#125;</code></pre><h1 id="统一管理光照衰减和阴影"><a href="#统一管理光照衰减和阴影" class="headerlink" title="统一管理光照衰减和阴影"></a>统一管理光照衰减和阴影</h1><ul><li>使用内置宏UNITY_LIGHT_ATTENUATION</li></ul><pre><code class="lang-c#">// Upgrade NOTE: replaced &#39;_Object2World&#39; with &#39;unity_ObjectToWorld&#39;// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;Shader &quot;Unity Shaders Book/Chapter 9/Attenuation And Shadow Use Build-in Functions&quot; &#123;    Properties &#123;        _Diffuse (&quot;Diffuse&quot;, Color) = (1, 1, 1, 1)        _Specular (&quot;Specular&quot;, Color) = (1, 1, 1, 1)        _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20    &#125;    SubShader &#123;        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;        Pass &#123;            // Pass for ambient light &amp; first pixel light (directional light)            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;            CGPROGRAM            // Apparently need to add this declaration            #pragma multi_compile_fwdbase                #pragma vertex vert            #pragma fragment frag            // Need these files to get built-in macros            #include &quot;Lighting.cginc&quot;            #include &quot;AutoLight.cginc&quot;            fixed4 _Diffuse;            fixed4 _Specular;            float _Gloss;            struct a2v &#123;                float4 vertex : POSITION;                float3 normal : NORMAL;            &#125;;            struct v2f &#123;                float4 pos : SV_POSITION;                float3 worldNormal : TEXCOORD0;                float3 worldPos : TEXCOORD1;                SHADOW_COORDS(2)            &#125;;            v2f vert(a2v v) &#123;                 v2f o;                 o.pos = UnityObjectToClipPos(v.vertex);                 o.worldNormal = UnityObjectToWorldNormal(v.normal);                 o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;                 // Pass shadow coordinates to pixel shader                 TRANSFER_SHADOW(o);                 return o;            &#125;            fixed4 frag(v2f i) : SV_Target &#123;                fixed3 worldNormal = normalize(i.worldNormal);                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;                 fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * max(0, dot(worldNormal, worldLightDir));                 fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));                 fixed3 halfDir = normalize(worldLightDir + viewDir);                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss);                // UNITY_LIGHT_ATTENUATION not only compute attenuation, but also shadow infos                //接受三个参数：atten(会帮助声明)，i:计算阴影，i.worldPos用来转换到光源空间                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);                return fixed4(ambient + (diffuse + specular) * atten, 1.0);            &#125;            ENDCG        &#125;        Pass &#123;            // Pass for other pixel lights            Tags &#123; &quot;LightMode&quot;=&quot;ForwardAdd&quot; &#125;            Blend One One            CGPROGRAM            // Apparently need to add this declaration            #pragma multi_compile_fwdadd            // Use the line below to add shadows for point and spot lights//            #pragma multi_compile_fwdadd_fullshadows            #pragma vertex vert            #pragma fragment frag            #include &quot;Lighting.cginc&quot;            #include &quot;AutoLight.cginc&quot;            fixed4 _Diffuse;            fixed4 _Specular;            float _Gloss;            struct a2v &#123;                float4 vertex : POSITION;                float3 normal : NORMAL;            &#125;;            struct v2f &#123;                float4 pos : SV_POSITION;                float3 worldNormal : TEXCOORD0;                float3 worldPos : TEXCOORD1;                SHADOW_COORDS(2)            &#125;;            v2f vert(a2v v) &#123;                 v2f o;                 o.pos = UnityObjectToClipPos(v.vertex);                 o.worldNormal = UnityObjectToWorldNormal(v.normal);                 o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;                 // Pass shadow coordinates to pixel shader                 TRANSFER_SHADOW(o);                 return o;            &#125;            fixed4 frag(v2f i) : SV_Target &#123;                fixed3 worldNormal = normalize(i.worldNormal);                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));                 fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * max(0, dot(worldNormal, worldLightDir));                 fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));                 fixed3 halfDir = normalize(worldLightDir + viewDir);                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss);                // UNITY_LIGHT_ATTENUATION not only compute attenuation, but also shadow infos                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);                return fixed4((diffuse + specular) * atten, 1.0);            &#125;            ENDCG        &#125;    &#125;    FallBack &quot;Specular&quot;&#125;</code></pre><h1 id="透明物体的阴影"><a href="#透明物体的阴影" class="headerlink" title="透明物体的阴影"></a>透明物体的阴影</h1><p>在Fallback中调用“Transparent/Cutout/VertexLit”</p>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第九章：更复杂的光照 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
            <tag> unity </tag>
            
            <tag> 阴影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双面渲染的透明效果</title>
      <link href="/posts/13d813c7.html"/>
      <url>/posts/13d813c7.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用Cull命令"><a href="#使用Cull命令" class="headerlink" title="使用Cull命令"></a>使用Cull命令</h1><ul><li>Cull Back|Front|Off,不渲染背面|前面|关闭</li></ul><h2 id="透明度测试的双面渲染"><a href="#透明度测试的双面渲染" class="headerlink" title="透明度测试的双面渲染"></a>透明度测试的双面渲染</h2><pre><code class="lang-c#">// Upgrade NOTE: replaced &#39;_Object2World&#39; with &#39;unity_ObjectToWorld&#39;// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;Shader &quot;Unity Shaders Book/Chapter 8/Alpha Test With Both Side&quot; &#123;    Properties &#123;        _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Cutoff (&quot;Alpha Cutoff&quot;, Range(0, 1)) = 0.5    &#125;    SubShader &#123;        Tags &#123;&quot;Queue&quot;=&quot;AlphaTest&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;TransparentCutout&quot;&#125;        Pass &#123;            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;            // Turn off culling            Cull Off            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #include &quot;Lighting.cginc&quot;            fixed4 _Color;            sampler2D _MainTex;            float4 _MainTex_ST;            fixed _Cutoff;            struct a2v &#123;                float4 vertex : POSITION;                float3 normal : NORMAL;                float4 texcoord : TEXCOORD0;            &#125;;            struct v2f &#123;                float4 pos : SV_POSITION;                float3 worldNormal : TEXCOORD0;                float3 worldPos : TEXCOORD1;                float2 uv : TEXCOORD2;            &#125;;            v2f vert(a2v v) &#123;                v2f o;                o.pos = UnityObjectToClipPos(v.vertex);                o.worldNormal = UnityObjectToWorldNormal(v.normal);                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);                return o;            &#125;            fixed4 frag(v2f i) : SV_Target &#123;                fixed3 worldNormal = normalize(i.worldNormal);                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));                fixed4 texColor = tex2D(_MainTex, i.uv);                clip (texColor.a - _Cutoff);                fixed3 albedo = texColor.rgb * _Color.rgb;                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;                fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir));                return fixed4(ambient + diffuse, 1.0);            &#125;            ENDCG        &#125;    &#125;     FallBack &quot;Transparent/Cutout/VertexLit&quot;&#125;</code></pre><h2 id="透明度混和的双面渲染"><a href="#透明度混和的双面渲染" class="headerlink" title="透明度混和的双面渲染"></a>透明度混和的双面渲染</h2><p>写了两个Pass,用来渲染前面和后面，由于关闭了ZWrite,所以无法正确渲染前后面，所以需要分两个pass渲染，先后再前，确保遮挡。</p><pre><code class="lang-c#">// Upgrade NOTE: replaced &#39;_Object2World&#39; with &#39;unity_ObjectToWorld&#39;// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;Shader &quot;Unity Shaders Book/Chapter 8/Alpha Blend With Both Side&quot; &#123;    Properties &#123;        _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;        _AlphaScale (&quot;Alpha Scale&quot;, Range(0, 1)) = 1    &#125;    SubShader &#123;        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;        Pass &#123;            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;            // First pass renders only back faces 只渲染后面            Cull Front            ZWrite Off            Blend SrcAlpha OneMinusSrcAlpha            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #include &quot;Lighting.cginc&quot;            fixed4 _Color;            sampler2D _MainTex;            float4 _MainTex_ST;            fixed _AlphaScale;            struct a2v &#123;                float4 vertex : POSITION;                float3 normal : NORMAL;                float4 texcoord : TEXCOORD0;            &#125;;            struct v2f &#123;                float4 pos : SV_POSITION;                float3 worldNormal : TEXCOORD0;                float3 worldPos : TEXCOORD1;                float2 uv : TEXCOORD2;            &#125;;            v2f vert(a2v v) &#123;                v2f o;                o.pos = UnityObjectToClipPos(v.vertex);                o.worldNormal = UnityObjectToWorldNormal(v.normal);                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);                return o;            &#125;            fixed4 frag(v2f i) : SV_Target &#123;                fixed3 worldNormal = normalize(i.worldNormal);                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));                fixed4 texColor = tex2D(_MainTex, i.uv);                fixed3 albedo = texColor.rgb * _Color.rgb;                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;                fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir));                return fixed4(ambient + diffuse, texColor.a * _AlphaScale);            &#125;            ENDCG        &#125;        Pass &#123;            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;            // Second pass renders only front faces 只渲染前面            Cull Back            ZWrite Off            Blend SrcAlpha OneMinusSrcAlpha            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #include &quot;Lighting.cginc&quot;            fixed4 _Color;            sampler2D _MainTex;            float4 _MainTex_ST;            fixed _AlphaScale;            struct a2v &#123;                float4 vertex : POSITION;                float3 normal : NORMAL;                float4 texcoord : TEXCOORD0;            &#125;;            struct v2f &#123;                float4 pos : SV_POSITION;                float3 worldNormal : TEXCOORD0;                float3 worldPos : TEXCOORD1;                float2 uv : TEXCOORD2;            &#125;;            v2f vert(a2v v) &#123;                v2f o;                o.pos = UnityObjectToClipPos(v.vertex);                o.worldNormal = UnityObjectToWorldNormal(v.normal);                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);                return o;            &#125;            fixed4 frag(v2f i) : SV_Target &#123;                fixed3 worldNormal = normalize(i.worldNormal);                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));                fixed4 texColor = tex2D(_MainTex, i.uv);                fixed3 albedo = texColor.rgb * _Color.rgb;                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;                fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir));                return fixed4(ambient + diffuse, texColor.a * _AlphaScale);            &#125;            ENDCG        &#125;    &#125;     FallBack &quot;Transparent/VertexLit&quot;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第八章：透明效果 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
            <tag> unity </tag>
            
            <tag> 透明效果 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>透明基础</title>
      <link href="/posts/327f022c.html"/>
      <url>/posts/327f022c.html</url>
      
        <content type="html"><![CDATA[<h1 id="unity实现透明"><a href="#unity实现透明" class="headerlink" title="unity实现透明"></a>unity实现透明</h1><ul><li>透明度测试<ol><li>只要一个片元的透明度不满足，就被舍弃</li><li>不需要关闭深度写入</li></ol></li><li>透明度混合<ol><li>可以获得真正的半透明效果</li><li>需要关闭深度写入</li><li>深度缓冲是只读</li></ol></li><li>关闭深度写入后，渲染顺序很重要<ol><li>先渲染所有不透明物体，并开启深度测试和深度写入</li><li>把半透明物体按距离摄像机远近排序，按照从后向前的顺序渲染，开启深度测试的同时关闭深度写入。</li></ol></li></ul><h1 id="unityshader渲染顺序"><a href="#unityshader渲染顺序" class="headerlink" title="unityshader渲染顺序"></a>unityshader渲染顺序</h1><ul><li><p>渲染队列（render queue）,使用SubShader的Queue标签觉得模型归于哪个渲染队列。</p></li><li><p>unity使用整数索引来表示渲染队列，索引越小越早渲染</p><ul><li><p>unity提前定义的5个渲染队列</p><p>|    名称     | 索引号 |                             描述                             |<br>| :————-: | :——: | :—————————————————————————————: |<br>| Background  |  1000  |      会在任何其他队列前被渲染，一般用来绘制背景上的物体      |<br>|  Geometry   |  2000  |              默认渲染队列。不透明物体使用该队列              |<br>|  AlphaTest  |  2450  |  透明度测试的队列，所有不透明物体渲染后再渲染该队列更加高效  |<br>| Transparent |  3000  | 在G和A队列渲染后，按从后往前的顺序渲染，使用了透明度混合的物体的队列 |<br>|   Overlay   |  4000  |   用于实现叠加效果，任何需要最后渲染的物体都应该使用该队列   |</p><p>在unityshader中Queue放在Tags当中</p><pre><code class="lang-c#">SubShader&#123;    Tags&#123;&quot;Queue&quot;=&quot;Transparent&quot;&#125;    Pass&#123;        ZWrite Off//可以写在pass中，表示在该pass中关闭，写在SubShader中可关闭所有Pa    &#125;&#125;</code></pre></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第八章：透明效果 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
            <tag> unity </tag>
            
            <tag> 透明效果 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>透明度测试</title>
      <link href="/posts/aa44d110.html"/>
      <url>/posts/aa44d110.html</url>
      
        <content type="html"><![CDATA[<h1 id="透明度测试"><a href="#透明度测试" class="headerlink" title="透明度测试"></a>透明度测试</h1><pre><code class="lang-tex">//使用该函数可以进行透明度测试void clip(x)x&lt;0则被丢弃</code></pre><pre><code class="lang-c#">// Upgrade NOTE: replaced &#39;_Object2World&#39; with &#39;unity_ObjectToWorld&#39;// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;Shader &quot;Unity Shaders Book/Chapter 8/Alpha Test&quot; &#123;    Properties &#123;        _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;        //设置阈值        _Cutoff (&quot;Alpha Cutoff&quot;, Range(0, 1)) = 0.5    &#125;    SubShader &#123;    //透明度测试队列，不受投影器影响，RenderType一般用于着色器替换，这里暂时不深入研究        Tags &#123;&quot;Queue&quot;=&quot;AlphaTest&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;TransparentCutout&quot;&#125;        Pass &#123;            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #include &quot;Lighting.cginc&quot;            fixed4 _Color;            sampler2D _MainTex;            float4 _MainTex_ST;            fixed _Cutoff;            struct a2v &#123;                float4 vertex : POSITION;                float3 normal : NORMAL;                float4 texcoord : TEXCOORD0;            &#125;;            struct v2f &#123;                float4 pos : SV_POSITION;                float3 worldNormal : TEXCOORD0;                float3 worldPos : TEXCOORD1;                float2 uv : TEXCOORD2;            &#125;;            v2f vert(a2v v) &#123;                v2f o;                o.pos = UnityObjectToClipPos(v.vertex);                o.worldNormal = UnityObjectToWorldNormal(v.normal);                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;                //其实就是重复次数和偏移                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);                return o;            &#125;            fixed4 frag(v2f i) : SV_Target &#123;                fixed3 worldNormal = normalize(i.worldNormal);                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));                fixed4 texColor = tex2D(_MainTex, i.uv);                // Alpha test如果小于阈值就舍弃                clip (texColor.a - _Cutoff);                // Equal to //                if ((texColor.a - _Cutoff) &lt; 0.0) &#123;//                    discard;//                &#125;                fixed3 albedo = texColor.rgb * _Color.rgb;                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;                fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir));                return fixed4(ambient + diffuse, 1.0);            &#125;            ENDCG        &#125;    &#125;     FallBack &quot;Transparent/Cutout/VertexLit&quot;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第八章：透明效果 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
            <tag> unity </tag>
            
            <tag> 透明效果 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光照知识</title>
      <link href="/posts/d8d2f61a.html"/>
      <url>/posts/d8d2f61a.html</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>请优先学习计算机图形学，推荐老师：闫令琪</p><p>图像包含</p><ol><li>光源</li><li>物体反射</li></ol><h1 id="光源"><a href="#光源" class="headerlink" title="光源"></a>光源</h1><ul><li>使用辐照度量化光</li></ul><h1 id="吸收和散射"><a href="#吸收和散射" class="headerlink" title="吸收和散射"></a>吸收和散射</h1><ul><li>散射：只改变光线方向，不改变光的密度和颜色<ul><li>折射refraction或透射transmission：进入物体内部</li><li>反射reflection：散射到物体外部</li></ul></li><li>吸收：只改变光的密度和颜色，不改变方向</li><li>从物体表面重新发射出的光线将具有和入射光线不同的方向分布和颜色</li><li>高光反射，漫反射，出射度exitance</li></ul><h1 id="着色"><a href="#着色" class="headerlink" title="着色"></a>着色</h1><p>指根据材质属性，光源信息用一个等式去计算某一个观察方向的出射度的过程。</p><p>等式：光照模型，不同的lighting model 可以描述不同的表面</p><h1 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h1><p>用来解释当光线从某个方向照射到一个表面时，有多少光线被反射，反射的方向有哪些。</p><p>即给定入射光线的方向和辐照度，brdf可以给出某个出射方向上的光照能量分布。</p>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第六章：unity基础光照 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unity实现基础光照</title>
      <link href="/posts/bcc6a719.html"/>
      <url>/posts/bcc6a719.html</url>
      
        <content type="html"><![CDATA[<h1 id="环境光和自发光"><a href="#环境光和自发光" class="headerlink" title="环境光和自发光"></a>环境光和自发光</h1><p><img src="https://gitee.com/yurain11/drawing-bed/raw/master/img/202304052209553.png" alt="image-20230405220912171"></p><h1 id="实现漫反射光照"><a href="#实现漫反射光照" class="headerlink" title="实现漫反射光照"></a>实现漫反射光照</h1><h2 id="顶点着色器中计算"><a href="#顶点着色器中计算" class="headerlink" title="顶点着色器中计算"></a>顶点着色器中计算</h2><pre><code class="lang-c#">// Upgrade NOTE: replaced &#39;_World2Object&#39; with &#39;unity_WorldToObject&#39;Shader &quot;MyShader/Chapter 6/diffuse&quot;&#123;    Properties&#123;        _Diffuese(&quot;Diffuse&quot;,Color)=(1,1,1,1)    &#125;    SubShader&#123;        Pass&#123;            //指定光照模式为向前渲染，定义正确的mode,才能得到内置光照变量            Tags&#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            //使用内置的一些变量需要使用            #include &quot;Lighting.cginc&quot;            //定义匹配的变量            fixed4 _Diffuese;            struct a2v&#123;                float4 vertex:POSITION;                //在顶点着色器中计算                float3 normal:NORMAL;            &#125;;            struct v2f&#123;                float4 pos:SV_POSITION;                fixed3 color:COLOR;            &#125;;            v2f vert(a2v v)&#123;                v2f o;                //模型空间转换到裁剪空间                o.pos=UnityObjectToClipPos(v.vertex);                //获得环境光                fixed3 ambient=UNITY_LIGHTMODEL_AMBIENT.xyz;                //转换到世界空间计算                fixed3 worldNormal=normalize(mul(v.normal,(float3x3)unity_WorldToObject));                fixed3 worldLight=normalize(_WorldSpaceLightPos0.xyz);                //saturate:如果在0-1之间不变，大于1取1，小于0取0                fixed3 diffuse=_LightColor0.rgb*_Diffuese.rgb*saturate(dot(worldNormal,worldLight));                o.color=ambient+diffuse;                return o;            &#125;            fixed4 frag(v2f i):SV_Target&#123;                return fixed4(i.color,1.0);            &#125;            ENDCG        &#125;    &#125;Fallback &quot;DIFFUSE&quot;&#125;</code></pre><h2 id="片元着色器中计算"><a href="#片元着色器中计算" class="headerlink" title="片元着色器中计算"></a>片元着色器中计算</h2><pre><code class="lang-c#">Shader &quot;MyShader/Chapter 6/diffuse_frag&quot;&#123;    Properties&#123;        _Diffuese(&quot;Diffuse&quot;,Color)=(1,1,1,1)    &#125;    SubShader&#123;        Pass&#123;            //指定光照模式为向前渲染，定义正确的mode,才能得到内置光照变量            Tags&#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            //使用内置的一些变量需要使用            #include &quot;Lighting.cginc&quot;            //定义匹配的变量            fixed4 _Diffuese;            struct a2v&#123;                float4 vertex:POSITION;                float3 normal:NORMAL;            &#125;;            struct v2f&#123;                float4 pos:SV_POSITION;                float3 worldNormal:TEXCOORD0;            &#125;;            v2f vert(a2v v)&#123;                v2f o;                //模型空间转换到裁剪空间                o.pos=UnityObjectToClipPos(v.vertex);                o.worldNormal=mul(v.normal,(float3x3)unity_WorldToObject);                    return o;            &#125;            fixed4 frag(v2f i):SV_Target&#123;                fixed3 ambient=UNITY_LIGHTMODEL_AMBIENT.xyz;                fixed3 worldLight=normalize(_WorldSpaceLightPos0.xyz);                    float3 worldNormal=normalize(i.worldNormal);                fixed3 diffuse=_LightColor0.rgb*_Diffuese.rgb*saturate(dot(worldNormal,worldLight));                fixed3 color=ambient+diffuse;                return fixed4(color,1.0);            &#125;            ENDCG        &#125;    &#125;Fallback &quot;DIFFUSE&quot;&#125;</code></pre><h2 id="半兰伯特光照模型"><a href="#半兰伯特光照模型" class="headerlink" title="半兰伯特光照模型"></a>半兰伯特光照模型</h2><ul><li>原理：把余弦值从[-1,1]映射到[0,1](*0.5+0.5)</li></ul><pre><code class="lang-c#">Shader &quot;MyShader/Chapter 6/diffuse_halfLambort&quot;&#123;    Properties&#123;        _Diffuese(&quot;Diffuse&quot;,Color)=(1,1,1,1)    &#125;    SubShader&#123;        Pass&#123;            //指定光照模式为向前渲染，定义正确的mode,才能得到内置光照变量            Tags&#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            //使用内置的一些变量需要使用            #include &quot;Lighting.cginc&quot;            //定义匹配的变量            fixed4 _Diffuese;            struct a2v&#123;                float4 vertex:POSITION;                float3 normal:NORMAL;            &#125;;            struct v2f&#123;                float4 pos:SV_POSITION;                float3 worldNormal:TEXCOORD0;            &#125;;            v2f vert(a2v v)&#123;                v2f o;                //模型空间转换到裁剪空间                o.pos=UnityObjectToClipPos(v.vertex);                o.worldNormal=mul(v.normal,(float3x3)unity_WorldToObject);                    return o;            &#125;            fixed4 frag(v2f i):SV_Target&#123;                fixed3 ambient=UNITY_LIGHTMODEL_AMBIENT.xyz;                fixed3 worldLight=normalize(_WorldSpaceLightPos0.xyz);                    float3 worldNormal=normalize(i.worldNormal);                fixed3 diffuse=_LightColor0.rgb*_Diffuese.rgb*saturate(dot(worldNormal,worldLight)*0.5+0.5);                fixed3 color=ambient+diffuse;                return fixed4(color,1.0);            &#125;            ENDCG        &#125;    &#125;Fallback &quot;DIFFUSE&quot;&#125;</code></pre><h1 id="实现高光反射"><a href="#实现高光反射" class="headerlink" title="实现高光反射"></a>实现高光反射</h1><h2 id="顶点"><a href="#顶点" class="headerlink" title="顶点"></a>顶点</h2><pre><code class="lang-c#">Shader &quot;MyShader/Chapter 6/specular_vert&quot;&#123;    Properties&#123;        _Diffuese(&quot;Diffuse&quot;,Color)=(1,1,1,1)        _Specular(&quot;Specular&quot;,Color)=(1,1,1,1)        _Gloss(&quot;Gloss&quot;,Range(8.0,256))=20    &#125;    SubShader&#123;        Pass&#123;            //指定光照模式为向前渲染，定义正确的mode,才能得到内置光照变量            Tags&#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            //使用内置的一些变量需要使用            #include &quot;Lighting.cginc&quot;            //定义匹配的变量            fixed4 _Diffuese;            fixed4 _Specular;            float _Gloss;            struct a2v&#123;                float4 vertex:POSITION;                //在顶点着色器中计算                float3 normal:NORMAL;            &#125;;            struct v2f&#123;                float4 pos:SV_POSITION;                fixed3 color:COLOR;            &#125;;            v2f vert(a2v v)&#123;                v2f o;                //模型空间转换到裁剪空间                o.pos=UnityObjectToClipPos(v.vertex);                //获得环境光                fixed3 ambient=UNITY_LIGHTMODEL_AMBIENT.xyz;                //转换到世界空间计算                fixed3 worldNormal=normalize(mul(v.normal,(float3x3)unity_WorldToObject));                fixed3 worldLight=normalize(_WorldSpaceLightPos0.xyz);                //saturate:如果在0-1之间不变，大于1取1，小于0取0                fixed3 diffuse=_LightColor0.rgb*_Diffuese.rgb*saturate(dot(worldNormal,worldLight));                fixed3 reflectDir=(normalize(reflect(-worldLight,worldNormal)));                fixed3 viewDir=normalize(_WorldSpaceCameraPos.xyz-mul(unity_ObjectToWorld,v.vertex).xyz);                fixed3 specular=_LightColor0.rgb*_Specular.rgb*pow(saturate(dot(reflectDir,viewDir)),_Gloss);                o.color=ambient+diffuse+specular;                return o;            &#125;            fixed4 frag(v2f i):SV_Target&#123;                return fixed4(i.color,1.0);            &#125;            ENDCG        &#125;    &#125;Fallback &quot;DIFFUSE&quot;&#125;</code></pre><h2 id="片元"><a href="#片元" class="headerlink" title="片元"></a>片元</h2><pre><code class="lang-c#">Shader &quot;MyShader/Chapter 6/specular_frag&quot;&#123;    Properties&#123;        _Diffuese(&quot;Diffuse&quot;,Color)=(1,1,1,1)        _Specular(&quot;Specular&quot;,Color)=(1,1,1,1)        _Gloss(&quot;Gloss&quot;,Range(8.0,256))=20    &#125;    SubShader&#123;        Pass&#123;            //指定光照模式为向前渲染，定义正确的mode,才能得到内置光照变量            Tags&#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            //使用内置的一些变量需要使用            #include &quot;Lighting.cginc&quot;            //定义匹配的变量            fixed4 _Diffuese;            fixed4 _Specular;            float _Gloss;            struct a2v&#123;                float4 vertex:POSITION;                float3 normal:NORMAL;            &#125;;            struct v2f&#123;                float4 pos:SV_POSITION;                float3 worldNormal:TEXCOORD0;                float3 worldPos:TEXCOORD1;            &#125;;            v2f vert(a2v v)&#123;                v2f o;                //模型空间转换到裁剪空间                o.pos=UnityObjectToClipPos(v.vertex);                o.worldNormal=mul(v.normal,(float3x3)unity_WorldToObject);                    o.worldPos=(unity_ObjectToWorld,v.vertex).xyz;                return o;            &#125;            fixed4 frag(v2f i):SV_Target&#123;                fixed3 ambient=UNITY_LIGHTMODEL_AMBIENT.xyz;                fixed3 worldLight=normalize(_WorldSpaceLightPos0.xyz);                    float3 worldNormal=normalize(i.worldNormal);                fixed3 diffuse=_LightColor0.rgb*_Diffuese.rgb*saturate(dot(worldNormal,worldLight));                fixed3 reflectDir=(normalize(reflect(-worldLight,worldNormal)));                fixed3 viewDir=normalize(_WorldSpaceCameraPos.xyz-i.worldPos);                fixed3 specular=_LightColor0.rgb*_Specular.rgb*pow(saturate(dot(reflectDir,viewDir)),_Gloss);                fixed3 color=ambient+diffuse+specular;                return fixed4(color,1.0);            &#125;            ENDCG        &#125;    &#125;Fallback &quot;DIFFUSE&quot;&#125;</code></pre><h2 id="blinn-phong"><a href="#blinn-phong" class="headerlink" title="blinn-phong"></a>blinn-phong</h2><pre><code class="lang-c#">Shader &quot;MyShader/Chapter 6/specular_Blinn-Phong&quot;&#123;    Properties&#123;        _Diffuese(&quot;Diffuse&quot;,Color)=(1,1,1,1)        _Specular(&quot;Specular&quot;,Color)=(1,1,1,1)        _Gloss(&quot;Gloss&quot;,Range(8.0,256))=20    &#125;    SubShader&#123;        Pass&#123;            //指定光照模式为向前渲染，定义正确的mode,才能得到内置光照变量            Tags&#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            //使用内置的一些变量需要使用            #include &quot;Lighting.cginc&quot;            //定义匹配的变量            fixed4 _Diffuese;            fixed4 _Specular;            float _Gloss;            struct a2v&#123;                float4 vertex:POSITION;                float3 normal:NORMAL;            &#125;;            struct v2f&#123;                float4 pos:SV_POSITION;                float3 worldNormal:TEXCOORD0;                float3 worldPos:TEXCOORD1;            &#125;;            v2f vert(a2v v)&#123;                v2f o;                //模型空间转换到裁剪空间                o.pos=UnityObjectToClipPos(v.vertex);                o.worldNormal=mul(v.normal,(float3x3)unity_WorldToObject);                    o.worldPos=(unity_ObjectToWorld,v.vertex).xyz;                return o;            &#125;            fixed4 frag(v2f i):SV_Target&#123;                fixed3 ambient=UNITY_LIGHTMODEL_AMBIENT.xyz;                fixed3 worldLight=normalize(_WorldSpaceLightPos0.xyz);                    float3 worldNormal=normalize(i.worldNormal);                fixed3 diffuse=_LightColor0.rgb*_Diffuese.rgb*saturate(dot(worldNormal,worldLight));                //fixed3 reflectDir=(normalize(reflect(-worldLight,worldNormal)));                fixed3 viewDir=normalize(_WorldSpaceCameraPos.xyz-i.worldPos);                fixed3 halfDir=normalize(worldLight+viewDir);                fixed3 specular=_LightColor0.rgb*_Specular.rgb*pow(saturate(dot(worldNormal,halfDir)),_Gloss);                fixed3 color=ambient+diffuse+specular;                return fixed4(color,1.0);            &#125;            ENDCG        &#125;    &#125;Fallback &quot;DIFFUSE&quot;&#125;</code></pre><h2 id="使用内置的函数得到方向"><a href="#使用内置的函数得到方向" class="headerlink" title="使用内置的函数得到方向"></a>使用内置的函数得到方向</h2><pre><code class="lang-c#">Shader &quot;MyShader/Chapter 6/specular_Blinn-Phong&quot;&#123;    Properties&#123;        _Diffuese(&quot;Diffuse&quot;,Color)=(1,1,1,1)        _Specular(&quot;Specular&quot;,Color)=(1,1,1,1)        _Gloss(&quot;Gloss&quot;,Range(8.0,256))=20    &#125;    SubShader&#123;        Pass&#123;            //指定光照模式为向前渲染，定义正确的mode,才能得到内置光照变量            Tags&#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            //使用内置的一些变量需要使用            #include &quot;Lighting.cginc&quot;            //定义匹配的变量            fixed4 _Diffuese;            fixed4 _Specular;            float _Gloss;            struct a2v&#123;                float4 vertex:POSITION;                float3 normal:NORMAL;            &#125;;            struct v2f&#123;                float4 pos:SV_POSITION;                float3 worldNormal:TEXCOORD0;                float3 worldPos:TEXCOORD1;            &#125;;            v2f vert(a2v v)&#123;                v2f o;                //模型空间转换到裁剪空间                o.pos=UnityObjectToClipPos(v.vertex);                //o.worldNormal=mul(v.normal,(float3x3)unity_WorldToObject);                o.worldNormal=UnityObjectToWorldNormal(v.normal);                o.worldPos=(unity_ObjectToWorld,v.vertex).xyz;                return o;            &#125;            fixed4 frag(v2f i):SV_Target&#123;                fixed3 ambient=UNITY_LIGHTMODEL_AMBIENT.xyz;                fixed3 worldLight=normalize(UnityWorldSpaceLightDir(i.worldPos));                    float3 worldNormal=normalize(i.worldNormal);                fixed3 diffuse=_LightColor0.rgb*_Diffuese.rgb*saturate(dot(worldNormal,worldLight));                //fixed3 reflectDir=(normalize(reflect(-worldLight,worldNormal)));                fixed3 viewDir=normalize(UnityWorldSpaceViewDir(i.worldPos));                fixed3 halfDir=normalize(worldLight+viewDir);                fixed3 specular=_LightColor0.rgb*_Specular.rgb*pow(saturate(dot(worldNormal,halfDir)),_Gloss);                fixed3 color=ambient+diffuse+specular;                return fixed4(color,1.0);            &#125;            ENDCG        &#125;    &#125;Fallback &quot;DIFFUSE&quot;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第六章：unity基础光照 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渲染纹理</title>
      <link href="/posts/3ae1c68d.html"/>
      <url>/posts/3ae1c68d.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是渲染纹理"><a href="#什么是渲染纹理" class="headerlink" title="什么是渲染纹理"></a>什么是渲染纹理</h1><p>GPU允许我们把整个三维场景渲染到一个中间缓冲中，即<strong>渲染目标纹理</strong>，<strong>多重渲染目标</strong>可以把场景渲染到多个渲染目标纹理当中，而不需要为每个目标单独渲染一次整个场景。</p><p>unity为渲染目标纹理定义了一种专门的纹理类型：<strong>渲染纹理</strong></p><p>使用方法：</p><ul><li><p>在project目录下创建渲染纹理，把某个摄像机的渲染纹理目标设置为该渲染纹理。</p><p>该相机的渲染结果会实时更新到渲染纹理当中</p></li><li><p>使用屏幕后处理的方式使用GrabPass和OnRenderImage函数来获得当前屏幕图像。然后就可以进行图像处理。</p></li></ul><h1 id="实现镜子效果"><a href="#实现镜子效果" class="headerlink" title="实现镜子效果"></a>实现镜子效果</h1><p><img src="https://gitee.com/yurain11/drawing-bed/raw/master/img/202304131533969.png" alt="image-20230413153319588"></p><ul><li><p>将希望镜子呈现的图像通过摄像机显示，即在背面设置一个相机，将渲染纹理通过面片显示出来。</p></li><li><p>将渲染纹理赋给shader的texture即可</p></li></ul><pre><code class="lang-c#">//代码如下// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;Shader &quot;Unity Shaders Book/Chapter 10/Mirror&quot; &#123;    Properties &#123;        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;    &#125;    SubShader &#123;        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;        Pass &#123;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            sampler2D _MainTex;            struct a2v &#123;                float4 vertex : POSITION;                float3 texcoord : TEXCOORD0;            &#125;;            struct v2f &#123;                float4 pos : SV_POSITION;                float2 uv : TEXCOORD0;            &#125;;            v2f vert(a2v v) &#123;                v2f o;                o.pos = UnityObjectToClipPos(v.vertex);                o.uv = v.texcoord;                // Mirror needs to filp x,翻转纹理，用于模拟镜子                o.uv.x = 1 - o.uv.x;                return o;            &#125;            fixed4 frag(v2f i) : SV_Target &#123;                return tex2D(_MainTex, i.uv);            &#125;            ENDCG        &#125;    &#125;      FallBack Off&#125;</code></pre><h1 id="玻璃效果"><a href="#玻璃效果" class="headerlink" title="玻璃效果"></a>玻璃效果</h1><p><img src="https://gitee.com/yurain11/drawing-bed/raw/master/img/202304131631099.png" alt="image-20230413163135832"></p><p>与简单的透明混合不同，使用GrabPass可以对物体后面的图像进行更加复杂的处理，比如使用法线来模拟折射效果。</p><ul><li>GrabPass：unity会把当前屏幕的图像绘制在一张纹理当中。</li><li>通常会使用GrabPass实现例如玻璃等透明材质的模拟</li></ul><h2 id="实现玻璃效果"><a href="#实现玻璃效果" class="headerlink" title="实现玻璃效果"></a>实现玻璃效果</h2><ol><li>使用法线纹理来修改模型的法线</li><li>通过Cubemap模拟玻璃反射</li><li>折射效果通过GrabPass抓取后面的图像进行后处理，使用切线空间的法线对屏幕纹理坐标进行偏移，再采样来模拟折射。</li><li>最终结果中反射通过物体显示，而折射则需要在摄像机中才能实现。</li></ol><pre><code class="lang-c#">// Upgrade NOTE: replaced &#39;_Object2World&#39; with &#39;unity_ObjectToWorld&#39;// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;Shader &quot;Unity Shaders Book/Chapter 10/Glass Refraction&quot; &#123;    Properties &#123;        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;        _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125;        _Cubemap (&quot;Environment Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;        _Distortion (&quot;Distortion&quot;, Range(0, 100)) = 10        _RefractAmount (&quot;Refract Amount&quot;, Range(0.0, 1.0)) = 1.0    &#125;    SubShader &#123;        // We must be transparent, so other objects are drawn before this one.        Tags &#123; &quot;Queue&quot;=&quot;Transparent&quot; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;        // This pass grabs the screen behind the object into a texture.        // We can access the result in the next pass as _RefractionTex        //定义了抓取的图像会被存在哪        GrabPass &#123; &quot;_RefractionTex&quot; &#125;        Pass &#123;                    CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #include &quot;UnityCG.cginc&quot;            sampler2D _MainTex;            float4 _MainTex_ST;            sampler2D _BumpMap;            float4 _BumpMap_ST;            samplerCUBE _Cubemap;            float _Distortion;            fixed _RefractAmount;            sampler2D _RefractionTex;            float4 _RefractionTex_TexelSize;            struct a2v &#123;                float4 vertex : POSITION;                float3 normal : NORMAL;                float4 tangent : TANGENT;                 float2 texcoord: TEXCOORD0;            &#125;;            struct v2f &#123;                float4 pos : SV_POSITION;                float4 scrPos : TEXCOORD0;                float4 uv : TEXCOORD1;                float4 TtoW0 : TEXCOORD2;                  float4 TtoW1 : TEXCOORD3;                  float4 TtoW2 : TEXCOORD4;             &#125;;            v2f vert (a2v v) &#123;                v2f o;                o.pos = UnityObjectToClipPos(v.vertex);                //调用内置函数得到被抓取的屏幕图像的采样坐标                o.scrPos = ComputeGrabScreenPos(o.pos);                o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex);                o.uv.zw = TRANSFORM_TEX(v.texcoord, _BumpMap);                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;                  fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);                  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);                  fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w;                 o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);                  o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);                  o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);                  return o;            &#125;            fixed4 frag (v2f i) : SV_Target &#123;                        float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);                fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));                // Get the normal in tangent space                fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));                    // Compute the offset in tangent space                //乘以纹素大小，就是针对每块纹素的法线进行偏移，即可求出偏移量（归一化后的情况）                float2 offset = bump.xy * _Distortion * _RefractionTex_TexelSize.xy;                //将偏移量拓展到屏幕空间，计算出被偏移点的实际屏幕空间坐标                i.scrPos.xy = offset * i.scrPos.z + i.scrPos.xy;                //用被偏移后的坐标去采样原来看到的图像，就可以得到偏移图像                fixed3 refrCol = tex2D(_RefractionTex, i.scrPos.xy/i.scrPos.w).rgb;                // Convert the normal to world space                bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump)));                fixed3 reflDir = reflect(-worldViewDir, bump);                fixed4 texColor = tex2D(_MainTex, i.uv.xy);                fixed3 reflCol = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb;                fixed3 finalColor = reflCol * (1 - _RefractAmount) + refrCol * _RefractAmount;                return fixed4(finalColor, 1);            &#125;            ENDCG        &#125;    &#125;    FallBack &quot;Diffuse&quot;&#125;</code></pre><h1 id="渲染纹理vsGrabPass"><a href="#渲染纹理vsGrabPass" class="headerlink" title="渲染纹理vsGrabPass"></a>渲染纹理vsGrabPass</h1><p>GrabPass实现更加简单，</p><p>渲染纹理的效率更好：因为可以控制渲染的场景大小，而grabPass获取的是和显示屏一致的。</p><p>GrabPass需要CPU直接读取后备缓冲的数据，破坏和GPU的并行性。</p><p>Unity5引入命令缓冲command Buffer，可以得到类似抓屏效果。</p><h1 id="commad-buffers"><a href="#commad-buffers" class="headerlink" title="commad buffers"></a>commad buffers</h1>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第十章：程序纹理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
            <tag> unity </tag>
            
            <tag> 纹理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标准光照模型</title>
      <link href="/posts/88effdfc.html"/>
      <url>/posts/88effdfc.html</url>
      
        <content type="html"><![CDATA[<h1 id="自发光，高光反射，漫反射，环境光"><a href="#自发光，高光反射，漫反射，环境光" class="headerlink" title="自发光，高光反射，漫反射，环境光"></a>自发光，高光反射，漫反射，环境光</h1><h2 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h2><ul><li>使用环境光来近似模拟间接光照</li><li>$c_{ambined}=g_{ambient}$</li></ul><h2 id="自发光"><a href="#自发光" class="headerlink" title="自发光"></a>自发光</h2><ul><li>直接由光源发射入摄像机，直接使用材质的自发光颜色</li><li>$c_{emissive}=m_{emissive}$</li><li>在实时渲染中，自发光的表面不会照亮周围（不会被当做光源）</li></ul><h2 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h2><ul><li>视角的位置不重要，在任何反射方向的分布都是一样的</li><li>入射光的角度很重要</li><li>符合兰伯特定律：反射光线的强度与表面法线和光源方向的夹角的余弦值成正比。</li><li>$c_{diffise}=(c_{light}*m_{diffuse})·max(0,\hat{n}·\hat{l})$</li><li>n:法线，l:指向光源方向，c:光源颜色，m:物体漫反射颜色，max截取到0，防止被背面的光照亮。</li></ul><h2 id="高光反射"><a href="#高光反射" class="headerlink" title="高光反射"></a>高光反射</h2><h3 id="Phong模型"><a href="#Phong模型" class="headerlink" title="Phong模型"></a>Phong模型</h3><ul><li><p>用来计算完全镜面反射方向被反射的光线</p></li><li><p>$c_{specular}=(c_{light}·m_{specular})·max(0,\hat{v}·\hat{r})^{m_{gloss}}$</p></li><li>m~gloss~是材质的光泽度，也叫反光度，用来控制高光区域的大小，值越大，点越小。m~specular~是高光反射颜色，用来控制高光反射的强度和颜色。同样也要用max截取。$\hat{v}$是视角方向，$\hat{r}$是反射方向。</li></ul><h3 id="Blinn-Phong模型"><a href="#Blinn-Phong模型" class="headerlink" title="Blinn-Phong模型"></a>Blinn-Phong模型</h3><ul><li>使用$\hat{v}$和$\hat{l}$的中间方向$\hat{h}$和法线$\hat{n}$的夹角代替$\hat{v}$和$\hat{r}$的夹角</li><li>$c_{specular}=(c_{light}·m_{specular})·max(0,\hat{h}·\hat{n})^{m_{gloss}}$</li><li>计算量小，且效果影响不大，被广泛运用。</li></ul><h2 id="着色方式"><a href="#着色方式" class="headerlink" title="着色方式"></a>着色方式</h2><ul><li><p>逐像素：在片元着色器当中计算</p><p>Phong着色：通过对顶点法线进行插值得到片元的法线的方式</p><p>计算量小，有非线性运算（高光）,会出问题</p><p>片元内部颜色暗于顶点最高颜色，容易出现棱角现象。</p></li><li><p>逐顶点：在顶点着色器中计算</p><p>高洛德着色：在顶点上计算光照，在片元中线性插值得到颜色</p><p>计算量大，但不易出错</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第六章：unity基础光照 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>立方体纹理</title>
      <link href="/posts/fe7c9daf.html"/>
      <url>/posts/fe7c9daf.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是立方体纹理"><a href="#什么是立方体纹理" class="headerlink" title="什么是立方体纹理"></a>什么是立方体纹理</h1><ul><li><p>立方体纹理是环境映射的一种实现方式。</p></li><li><p>一共包含6张图像</p></li><li><p>好处：实现简单快速，效果好。</p><p>缺点：场景中引入新的物体，光源，或者物体发生移动时需要重新生成。</p><p>不能模拟多次反射的结果</p></li><li><p>尽量对凸面体使用立方体纹理。</p></li></ul><h2 id="天空盒子"><a href="#天空盒子" class="headerlink" title="天空盒子"></a>天空盒子</h2><p>用于模拟背景的一种方式。</p><p>添加天空盒子：</p><ol><li>新建材质，shader选择自带的Skybox/6 sided.</li><li>将图片附上，图片的wrap mode设置为clamp,</li><li>在window-rendering-lighting中的scene中将skybox设置为之前的材质</li><li>该设置会覆盖所有摄像机，如果希望使用不同的，需要给摄像机添加skybox组件。</li></ol><h2 id="创建环境映射的立方体纹理"><a href="#创建环境映射的立方体纹理" class="headerlink" title="创建环境映射的立方体纹理"></a>创建环境映射的立方体纹理</h2><ul><li><p>特殊布局的纹理创建</p><p>需要类似立方体展开图或者全景布局图，将texture type设置为cubemap</p></li><li><p>手动创建Cubemap</p><p>上面的方法</p></li><li><p>脚本生成</p><p>通过unity提供的Camera.RenderToCubemap函数实现，该函数可以把任意位置的场景图像储存到6张图像中。</p><pre><code class="lang-c#">using UnityEngine;using UnityEditor;using System.Collections;public class RenderCubemapWizard : ScriptableWizard &#123;    public Transform renderFromPosition;    public Cubemap cubemap;    void OnWizardUpdate () &#123;        helpString = &quot;Select transform to render from and cubemap to render into&quot;;        isValid = (renderFromPosition != null) &amp;&amp; (cubemap != null);    &#125;    void OnWizardCreate () &#123;        // create temporary camera for rendering        GameObject go = new GameObject( &quot;CubemapCamera&quot;);        go.AddComponent&lt;Camera&gt;();        // place it on the object        go.transform.position = renderFromPosition.position;        // render into cubemap                go.GetComponent&lt;Camera&gt;().RenderToCubemap(cubemap);        // destroy temporary camera        DestroyImmediate( go );    &#125;    [MenuItem(&quot;GameObject/Render into Cubemap&quot;)]    static void RenderCubemap () &#123;        ScriptableWizard.DisplayWizard&lt;RenderCubemapWizard&gt;(            &quot;Render cubemap&quot;, &quot;Render!&quot;);    &#125;&#125;</code></pre><p>通过调用该脚本就可以把一个位置的环境渲染到一个Cubemap当中。</p></li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><ul><li>通过视角方向的反射方向即可知道采样的位置。</li></ul><pre><code class="lang-C#">// Upgrade NOTE: replaced &#39;_Object2World&#39; with &#39;unity_ObjectToWorld&#39;// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;Shader &quot;Unity Shaders Book/Chapter 10/Reflection&quot; &#123;    Properties &#123;        _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)        //控制反射颜色        _ReflectColor (&quot;Reflection Color&quot;, Color) = (1, 1, 1, 1)        //控制反射程度        _ReflectAmount (&quot;Reflect Amount&quot;, Range(0, 1)) = 1        //导入Cubemap        _Cubemap (&quot;Reflection Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;    &#125;    SubShader &#123;        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;        Pass &#123;             Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;            CGPROGRAM            #pragma multi_compile_fwdbase            #pragma vertex vert            #pragma fragment frag            #include &quot;Lighting.cginc&quot;            #include &quot;AutoLight.cginc&quot;            fixed4 _Color;            fixed4 _ReflectColor;            fixed _ReflectAmount;            samplerCUBE _Cubemap;            struct a2v &#123;                float4 vertex : POSITION;                float3 normal : NORMAL;            &#125;;            struct v2f &#123;                float4 pos : SV_POSITION;                float3 worldPos : TEXCOORD0;                fixed3 worldNormal : TEXCOORD1;                fixed3 worldViewDir : TEXCOORD2;                fixed3 worldRefl : TEXCOORD3;                SHADOW_COORDS(4)            &#125;;            v2f vert(a2v v) &#123;                v2f o;                o.pos = UnityObjectToClipPos(v.vertex);                o.worldNormal = UnityObjectToWorldNormal(v.normal);                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;                o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);                // Compute the reflect dir in world space                //通过视角方向计算反射方向，即得到指向环境的方向，通过这个方向在Cubemap中采样                o.worldRefl = reflect(-o.worldViewDir, o.worldNormal);                TRANSFER_SHADOW(o);                return o;            &#125;            fixed4 frag(v2f i) : SV_Target &#123;                fixed3 worldNormal = normalize(i.worldNormal);                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));                        fixed3 worldViewDir = normalize(i.worldViewDir);                        fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;                fixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(0, dot(worldNormal, worldLightDir));                // Use the reflect dir in world space to access the cubemap                fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb * _ReflectColor.rgb;                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);                // Mix the diffuse color with the reflected color                //通过反射系数混合漫反射和反射，最后乘上光强衰减系数                fixed3 color = ambient + lerp(diffuse, reflection, _ReflectAmount) * atten;                return fixed4(color, 1.0);            &#125;            ENDCG        &#125;    &#125;    FallBack &quot;Reflective/VertexLit&quot;&#125;</code></pre><h2 id="折射"><a href="#折射" class="headerlink" title="折射"></a>折射</h2><ul><li><p>斯涅尔定律（Snell’s Law）</p><script type="math/tex; mode=display">\eta_1sin\theta_1=\eta_2sin\theta_2</script><p>一般来说需要计算两次折射：射入和射出</p><p>但是实时渲染一般模拟1次折射</p></li></ul><pre><code class="lang-c#">// Upgrade NOTE: replaced &#39;_Object2World&#39; with &#39;unity_ObjectToWorld&#39;// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;Shader &quot;Unity Shaders Book/Chapter 10/Refraction&quot; &#123;    Properties &#123;        _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)        _RefractColor (&quot;Refraction Color&quot;, Color) = (1, 1, 1, 1)        //折射比率        _RefractAmount (&quot;Refraction Amount&quot;, Range(0, 1)) = 1        //不同介质的透射比        _RefractRatio (&quot;Refraction Ratio&quot;, Range(0.1, 1)) = 0.5        _Cubemap (&quot;Refraction Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;    &#125;    SubShader &#123;        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;        Pass &#123;             Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;            CGPROGRAM            #pragma multi_compile_fwdbase                #pragma vertex vert            #pragma fragment frag            #include &quot;Lighting.cginc&quot;            #include &quot;AutoLight.cginc&quot;            fixed4 _Color;            fixed4 _RefractColor;            float _RefractAmount;            fixed _RefractRatio;            samplerCUBE _Cubemap;            struct a2v &#123;                float4 vertex : POSITION;                float3 normal : NORMAL;            &#125;;            struct v2f &#123;                float4 pos : SV_POSITION;                float3 worldPos : TEXCOORD0;                fixed3 worldNormal : TEXCOORD1;                fixed3 worldViewDir : TEXCOORD2;                fixed3 worldRefr : TEXCOORD3;                SHADOW_COORDS(4)            &#125;;            v2f vert(a2v v) &#123;                v2f o;                o.pos = UnityObjectToClipPos(v.vertex);                o.worldNormal = UnityObjectToWorldNormal(v.normal);                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;                o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);                // Compute the refract dir in world space                //需要入射方向，和法线，第三个两个介质的折射率之比，a-&gt;b，re=a/b                o.worldRefr = refract(-normalize(o.worldViewDir), normalize(o.worldNormal), _RefractRatio);                TRANSFER_SHADOW(o);                return o;            &#125;            fixed4 frag(v2f i) : SV_Target &#123;                fixed3 worldNormal = normalize(i.worldNormal);                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));                fixed3 worldViewDir = normalize(i.worldViewDir);                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;                fixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(0, dot(worldNormal, worldLightDir));                // Use the refract dir in world space to access the cubemap                fixed3 refraction = texCUBE(_Cubemap, i.worldRefr).rgb * _RefractColor.rgb;                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);                // Mix the diffuse color with the refract color                fixed3 color = ambient + lerp(diffuse, refraction, _RefractAmount) * atten;                return fixed4(color, 1.0);            &#125;            ENDCG        &#125;    &#125;     FallBack &quot;Reflective/VertexLit&quot;&#125;</code></pre><h2 id="菲涅尔反射"><a href="#菲涅尔反射" class="headerlink" title="菲涅尔反射"></a>菲涅尔反射</h2><p>原理：当光线照射到物体表面时，一部分反射，一部分发生折射和散射，被反射的光和入射光存在一定的比率关系。</p><p>菲涅尔等式：</p><p>近似公式：Schlick 菲涅尔近似等式：</p><script type="math/tex; mode=display">F_{Schlick}(v,n)=F_0+(1-F_0)(1-v·n)^5</script><p>F~0~是反射系数，控制反射强度，v是视角方向，n是法线</p><p>应用广泛的等式是Empricial菲涅尔近似等式：</p><script type="math/tex; mode=display">F_{Empricial}(v,n)=max(0,min(1,bias+scale\times(1-v·n)^{power}))</script><p>三个英文是控制项</p><pre><code class="lang-c#">// Upgrade NOTE: replaced &#39;_Object2World&#39; with &#39;unity_ObjectToWorld&#39;// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;//schlickjShader &quot;Unity Shaders Book/Chapter 10/Fresnel&quot; &#123;    Properties &#123;        _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)        _FresnelScale (&quot;Fresnel Scale&quot;, Range(0, 1)) = 0.5        _Cubemap (&quot;Reflection Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;    &#125;    SubShader &#123;        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;        Pass &#123;             Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;            CGPROGRAM            #pragma multi_compile_fwdbase            #pragma vertex vert            #pragma fragment frag            #include &quot;Lighting.cginc&quot;            #include &quot;AutoLight.cginc&quot;            fixed4 _Color;            fixed _FresnelScale;            samplerCUBE _Cubemap;            struct a2v &#123;                float4 vertex : POSITION;                float3 normal : NORMAL;            &#125;;            struct v2f &#123;                float4 pos : SV_POSITION;                float3 worldPos : TEXCOORD0;                  fixed3 worldNormal : TEXCOORD1;                  fixed3 worldViewDir : TEXCOORD2;                  fixed3 worldRefl : TEXCOORD3;                  SHADOW_COORDS(4)            &#125;;            v2f vert(a2v v) &#123;                v2f o;                o.pos = UnityObjectToClipPos(v.vertex);                o.worldNormal = UnityObjectToWorldNormal(v.normal);                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;                o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);                o.worldRefl = reflect(-o.worldViewDir, o.worldNormal);                TRANSFER_SHADOW(o);                return o;            &#125;            fixed4 frag(v2f i) : SV_Target &#123;                fixed3 worldNormal = normalize(i.worldNormal);                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));                fixed3 worldViewDir = normalize(i.worldViewDir);                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);                fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb;                fixed fresnel = _FresnelScale + (1 - _FresnelScale) * pow(1 - dot(worldViewDir, worldNormal), 5);                fixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(0, dot(worldNormal, worldLightDir));                //通过菲涅尔系数控制漫反射和反射的混合程度                fixed3 color = ambient + lerp(diffuse, reflection, saturate(fresnel)) * atten;                return fixed4(color, 1.0);            &#125;            ENDCG        &#125;    &#125;     FallBack &quot;Reflective/VertexLit&quot;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第十章：程序纹理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
            <tag> unity </tag>
            
            <tag> 纹理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顶点动画</title>
      <link href="/posts/3765f5c1.html"/>
      <url>/posts/3765f5c1.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用内置时间变量"><a href="#使用内置时间变量" class="headerlink" title="使用内置时间变量"></a>使用内置时间变量</h1><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">_Time</td><td style="text-align:center">float4</td><td style="text-align:center">自场景加载的时间（t/20,t,2t,3t）</td></tr><tr><td style="text-align:center">_SinTime</td><td style="text-align:center">float4</td><td style="text-align:center">t是时间的正弦值，（t/8,t/4,t/2,t）</td></tr><tr><td style="text-align:center">_CosTime</td><td style="text-align:center">float4</td><td style="text-align:center">t是时间的余弦值，（t/8,t/4,t/2,t）</td></tr><tr><td style="text-align:center">unity_DeltaTime</td><td style="text-align:center">float4</td><td style="text-align:center">dt是时间增量（dt,1/dt,smoothDt,1/smoothDt）</td></tr></tbody></table></div><h1 id="纹理动画"><a href="#纹理动画" class="headerlink" title="纹理动画"></a>纹理动画</h1><h2 id="帧序列动画"><a href="#帧序列动画" class="headerlink" title="帧序列动画"></a>帧序列动画</h2><p>主要思路：</p><ol><li>动画的每一帧都放在一张图中，需要对纹理图的采样区域不停变化。</li><li>需要通过时间变量进行变化</li><li>需要把采样的区域量化</li></ol><pre><code class="lang-c#">// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;Shader &quot;Unity Shaders Book/Chapter 11/Image Sequence Animation&quot; &#123;    Properties &#123;        _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)        _MainTex (&quot;Image Sequence&quot;, 2D) = &quot;white&quot; &#123;&#125;        _HorizontalAmount (&quot;Horizontal Amount&quot;, Float) = 4        _VerticalAmount (&quot;Vertical Amount&quot;, Float) = 4        _Speed (&quot;Speed&quot;, Range(1, 100)) = 30    &#125;    SubShader &#123;        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;        Pass &#123;            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;            ZWrite Off            Blend SrcAlpha OneMinusSrcAlpha            CGPROGRAM            #pragma vertex vert              #pragma fragment frag            #include &quot;UnityCG.cginc&quot;            fixed4 _Color;            sampler2D _MainTex;            float4 _MainTex_ST;            float _HorizontalAmount;            float _VerticalAmount;            float _Speed;            struct a2v &#123;                  float4 vertex : POSITION;                 float2 texcoord : TEXCOORD0;            &#125;;              struct v2f &#123;                  float4 pos : SV_POSITION;                float2 uv : TEXCOORD0;            &#125;;              v2f vert (a2v v) &#123;                  v2f o;                  o.pos = UnityObjectToClipPos(v.vertex);                  o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);                  return o;            &#125;              fixed4 frag (v2f i) : SV_Target &#123;                //floor函数用来取整                float time = floor(_Time.y * _Speed);                  float row = floor(time / _HorizontalAmount);                float column = time - row * _HorizontalAmount;//                half2 uv = float2(i.uv.x /_HorizontalAmount, i.uv.y / _VerticalAmount);//                uv.x += column / _HorizontalAmount;//                uv.y -= row / _VerticalAmount;                half2 uv = i.uv + half2(column, -row);                uv.x /=  _HorizontalAmount;                uv.y /= _VerticalAmount;                fixed4 c = tex2D(_MainTex, uv);                c.rgb *= _Color;                return c;            &#125;            ENDCG        &#125;      &#125;    FallBack &quot;Transparent/VertexLit&quot;&#125;</code></pre><h2 id="滚动的背景"><a href="#滚动的背景" class="headerlink" title="滚动的背景"></a>滚动的背景</h2><p>思路：对uv采样位置进行偏移，也是通过内置时间函数</p><pre><code class="lang-c#">// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;Shader &quot;Unity Shaders Book/Chapter 11/Scrolling Background&quot; &#123;    Properties &#123;        _MainTex (&quot;Base Layer (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;        _DetailTex (&quot;2nd Layer (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;        _ScrollX (&quot;Base layer Scroll Speed&quot;, Float) = 1.0        _Scroll2X (&quot;2nd layer Scroll Speed&quot;, Float) = 1.0        _Multiplier (&quot;Layer Multiplier&quot;, Float) = 1    &#125;    SubShader &#123;        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;        Pass &#123;             Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #include &quot;UnityCG.cginc&quot;            sampler2D _MainTex;            sampler2D _DetailTex;            float4 _MainTex_ST;            float4 _DetailTex_ST;            float _ScrollX;            float _Scroll2X;            float _Multiplier;            struct a2v &#123;                float4 vertex : POSITION;                float4 texcoord : TEXCOORD0;            &#125;;            struct v2f &#123;                float4 pos : SV_POSITION;                float4 uv : TEXCOORD0;            &#125;;            v2f vert (a2v v) &#123;                v2f o;                o.pos = UnityObjectToClipPos(v.vertex);                o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex) + frac(float2(_ScrollX, 0.0) * _Time.y);                o.uv.zw = TRANSFORM_TEX(v.texcoord, _DetailTex) + frac(float2(_Scroll2X, 0.0) * _Time.y);                return o;            &#125;            fixed4 frag (v2f i) : SV_Target &#123;                fixed4 firstLayer = tex2D(_MainTex, i.uv.xy);                fixed4 secondLayer = tex2D(_DetailTex, i.uv.zw);                fixed4 c = lerp(firstLayer, secondLayer, secondLayer.a);                c.rgb *= _Multiplier;                return c;            &#125;            ENDCG        &#125;    &#125;    FallBack &quot;VertexLit&quot;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第十一章：让画面动起来 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
            <tag> unity </tag>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顶点动画</title>
      <link href="/posts/3765f5c1.html"/>
      <url>/posts/3765f5c1.html</url>
      
        <content type="html"><![CDATA[<h1 id="流动的河流"><a href="#流动的河流" class="headerlink" title="流动的河流"></a>流动的河流</h1><p>思路:使用顶点动画</p><pre><code class="lang-c#">// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;Shader &quot;Unity Shaders Book/Chapter 11/Water&quot; &#123;    Properties &#123;        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)        _Magnitude (&quot;Distortion Magnitude&quot;, Float) = 1         _Frequency (&quot;Distortion Frequency&quot;, Float) = 1         _InvWaveLength (&quot;Distortion Inverse Wave Length&quot;, Float) = 10         _Speed (&quot;Speed&quot;, Float) = 0.5    &#125;    SubShader &#123;        //批处理会合并所有相关模型，模型会丢失自己的模型空间，所以在顶点动画        // Need to disable batching because of the vertex animation        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;DisableBatching&quot;=&quot;True&quot;&#125;        Pass &#123;            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;            ZWrite Off            Blend SrcAlpha OneMinusSrcAlpha            Cull Off            CGPROGRAM              #pragma vertex vert             #pragma fragment frag            #include &quot;UnityCG.cginc&quot;             sampler2D _MainTex;            float4 _MainTex_ST;            fixed4 _Color;            float _Magnitude;            float _Frequency;            float _InvWaveLength;            float _Speed;            struct a2v &#123;                float4 vertex : POSITION;                float4 texcoord : TEXCOORD0;            &#125;;            struct v2f &#123;                float4 pos : SV_POSITION;                float2 uv : TEXCOORD0;            &#125;;            v2f vert(a2v v) &#123;                v2f o;                float4 offset;                offset.yzw = float3(0.0, 0.0, 0.0);                //_Frequency控制频率，_InvWaveLength控制波长，_Magnitude控制振幅                offset.x = sin(_Frequency * _Time.y + v.vertex.x * _InvWaveLength + v.vertex.y * _InvWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude;                o.pos = UnityObjectToClipPos(v.vertex + offset);                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);                o.uv +=  float2(0.0, _Time.y * _Speed);                return o;            &#125;            fixed4 frag(v2f i) : SV_Target &#123;                fixed4 c = tex2D(_MainTex, i.uv);                c.rgb *= _Color.rgb;                return c;            &#125;             ENDCG        &#125;    &#125;    FallBack &quot;Transparent/VertexLit&quot;&#125;</code></pre><h1 id="广告牌"><a href="#广告牌" class="headerlink" title="广告牌"></a>广告牌</h1><p>目标：物体始终正对视角，摄像机</p><p>原理：物体的方向需要三个轴确定：表面法线（在这里用视角方向），向上方向，向右方向。</p><p>已知表面法线不会变的情况下，首先利用表面法线和原向上方向确定向右方向，然后利用表面法线和向右方向确定新的向上方向。</p><script type="math/tex; mode=display">right=up*normal\\up'=normal*right</script><pre><code class="lang-c#">// Upgrade NOTE: replaced &#39;_World2Object&#39; with &#39;unity_WorldToObject&#39;// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;Shader &quot;Unity Shaders Book/Chapter 11/Billboard&quot; &#123;    Properties &#123;        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)        _VerticalBillboarding (&quot;Vertical Restraints&quot;, Range(0, 1)) = 1     &#125;    SubShader &#123;        // Need to disable batching because of the vertex animation        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;DisableBatching&quot;=&quot;True&quot;&#125;        Pass &#123;             Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;            ZWrite Off            Blend SrcAlpha OneMinusSrcAlpha            Cull Off            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #include &quot;Lighting.cginc&quot;            sampler2D _MainTex;            float4 _MainTex_ST;            fixed4 _Color;            fixed _VerticalBillboarding;            struct a2v &#123;                float4 vertex : POSITION;                float4 texcoord : TEXCOORD0;            &#125;;            struct v2f &#123;                float4 pos : SV_POSITION;                float2 uv : TEXCOORD0;            &#125;;            v2f vert (a2v v) &#123;                v2f o;                // Suppose the center in object space is fixed                float3 center = float3(0, 0, 0);                float3 viewer = mul(unity_WorldToObject,float4(_WorldSpaceCameraPos, 1));                float3 normalDir = viewer - center;                // If _VerticalBillboarding equals 1, we use the desired view dir as the normal dir                // Which means the normal dir is fixed                // Or if _VerticalBillboarding equals 0, the y of normal is 0                // Which means the up dir is fixed                normalDir.y =normalDir.y * _VerticalBillboarding;                normalDir = normalize(normalDir);                // Get the approximate up dir                // If normal dir is already towards up, then the up dir is towards front                //如果向上方向和法线重合，就设置向上方向为（0，0，1）                float3 upDir = abs(normalDir.y) &gt; 0.999 ? float3(0, 0, 1) : float3(0, 1, 0);                float3 rightDir = normalize(cross(upDir, normalDir));                upDir = normalize(cross(normalDir, rightDir));                // Use the three vectors to rotate the quad                float3 centerOffs = v.vertex.xyz - center;                //对顶点进行偏移                float3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir * centerOffs.z;                o.pos = UnityObjectToClipPos(float4(localPos, 1));                o.uv = TRANSFORM_TEX(v.texcoord,_MainTex);                return o;            &#125;            fixed4 frag (v2f i) : SV_Target &#123;                fixed4 c = tex2D (_MainTex, i.uv);                c.rgb *= _Color.rgb;                return c;            &#125;            ENDCG        &#125;    &#125;     FallBack &quot;Transparent/VertexLit&quot;&#125;</code></pre><h1 id="顶点阴影"><a href="#顶点阴影" class="headerlink" title="顶点阴影"></a>顶点阴影</h1><p>原理：unity内置的阴影投射不涉及到顶点变换，所以如果我们需要阴影也有变形效果，需要自己写一个shadowCasterPass。</p>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第十一章：让画面动起来 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
            <tag> unity </tag>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序纹理</title>
      <link href="/posts/b3314196.html"/>
      <url>/posts/b3314196.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是程序纹理"><a href="#什么是程序纹理" class="headerlink" title="什么是程序纹理"></a>什么是程序纹理</h1><p>通过算法创建个性图案或者非常真实的自然元素</p><h1 id="实现程序材质"><a href="#实现程序材质" class="headerlink" title="实现程序材质"></a>实现程序材质</h1><p>通过脚本创建程序纹理</p><p>通过Substance Designer创建程序纹理和材质</p>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第十章：程序纹理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
            <tag> 纹理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>屏幕后处理脚本</title>
      <link href="/posts/98e7b614.html"/>
      <url>/posts/98e7b614.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是屏幕后处理"><a href="#什么是屏幕后处理" class="headerlink" title="什么是屏幕后处理"></a>什么是屏幕后处理</h1><p>屏幕后处理：指渲染整个场景得到屏幕图像后，再对这个图像进行一系列操作，实现各种屏幕特效。</p><p>unity提供抓取屏幕的接口<strong>OnRenderImage</strong></p><p><a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnRenderImage.html">Unity - Scripting API: MonoBehaviour.OnRenderImage(RenderTexture,RenderTexture) (unity3d.com)</a></p><p>利用<strong>Graphics.Blit</strong>函数完成对渲染纹理的处理</p><p><a href="https://docs.unity3d.com/ScriptReference/Graphics.Blit.html">Unity - Scripting API: Graphics.Blit (unity3d.com)</a></p><h1 id="屏幕后处理的基类"><a href="#屏幕后处理的基类" class="headerlink" title="屏幕后处理的基类"></a>屏幕后处理的基类</h1><p>作用：检查条件是否满足屏幕后处理，比如当前平台是否支持等</p><pre><code class="lang-c#">//PostEffectsBase.csusing UnityEngine;using System.Collections;//编辑器状态下可以执行该脚本[ExecuteInEditMode][RequireComponent (typeof(Camera))]public class PostEffectsBase : MonoBehaviour &#123;    // Called when start    protected void CheckResources() &#123;        bool isSupported = CheckSupport();        if (isSupported == false) &#123;            NotSupported();        &#125;    &#125;    // Called in CheckResources to check support on this platform    protected bool CheckSupport() &#123;        if (SystemInfo.supportsImageEffects == false || SystemInfo.supportsRenderTextures == false) &#123;            Debug.LogWarning(&quot;This platform does not support image effects or render textures.&quot;);            return false;        &#125;        return true;    &#125;    // Called when the platform doesn&#39;t support this effect    protected void NotSupported() &#123;        enabled = false;    &#125;    protected void Start() &#123;        CheckResources();    &#125;    // Called when need to create the material used by this effect    protected Material CheckShaderAndCreateMaterial(Shader shader, Material material) &#123;        if (shader == null) &#123;            return null;        &#125;        if (shader.isSupported &amp;&amp; material &amp;&amp; material.shader == shader)            return material;        if (!shader.isSupported) &#123;            return null;        &#125;        else &#123;            material = new Material(shader);            material.hideFlags = HideFlags.DontSave;            if (material)                return material;            else                 return null;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第十二章：屏幕后处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
            <tag> unity </tag>
            
            <tag> 屏幕后处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运动模糊</title>
      <link href="/posts/e53f72a2.html"/>
      <url>/posts/e53f72a2.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是运动模糊"><a href="#什么是运动模糊" class="headerlink" title="什么是运动模糊"></a>什么是运动模糊</h1><p>在摄像机曝光的时候，拍摄场景发生变换，就会产生模糊的画面。运动模糊可以让物体运动看起来更加真实平滑。</p><p>实现方法1:利用一块累计缓存accumulation buffer,用来混合多张连续的图像，当物体快速移动，我们取多张图像的平均值作为最后的图像。</p><p>缺点：性能消耗大，需要在同一帧渲染多次场景。</p><p>实现方法2：使用速度缓存velocity buffer，这个缓存存储像素当前的运动速度，利用该值决定模糊的方向。</p><h1 id="方法1实现"><a href="#方法1实现" class="headerlink" title="方法1实现"></a>方法1实现</h1><p>不需要渲染多次场景，只需要保存之前的渲染结果，不断把当前的渲染图像叠加之前的渲染图像，产生一种运动轨迹的视角效果。可以提高性能，但是模糊效果肯定不如之前的效果。</p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><pre><code class="lang-c#">using UnityEngine;using System.Collections;public class MotionBlur : PostEffectsBase &#123;    public Shader motionBlurShader;    private Material motionBlurMaterial = null;    public Material material &#123;          get &#123;            motionBlurMaterial = CheckShaderAndCreateMaterial(motionBlurShader, motionBlurMaterial);            return motionBlurMaterial;        &#125;      &#125;    //模糊系数    [Range(0.0f, 0.9f)]    public float blurAmount = 0.5f;    private RenderTexture accumulationTexture;    //在下一次叠加图像时先销毁之前的图像    void OnDisable() &#123;        DestroyImmediate(accumulationTexture);    &#125;    void OnRenderImage (RenderTexture src, RenderTexture dest) &#123;        if (material != null) &#123;            // Create the accumulation texture            //不仅判断是否为空，还要判断是否和当前屏幕尺寸匹配            if (accumulationTexture == null || accumulationTexture.width != src.width || accumulationTexture.height != src.height) &#123;                DestroyImmediate(accumulationTexture);                accumulationTexture = new RenderTexture(src.width, src.height, 0);                accumulationTexture.hideFlags = HideFlags.HideAndDontSave;                //初始化                Graphics.Blit(src, accumulationTexture);            &#125;            // We are accumulating motion over frames without clear/discard            // by design, so silence any performance warnings from Unity            //因为accumulationTexture是不被清除的，这样我们才可以把accumulationTexture和当前帧进行混合            //MarkRestoreExpected用于 声明在这里有一个renderTexture是预期的恢复操作（防止报错）            accumulationTexture.MarkRestoreExpected();            material.SetFloat(&quot;_BlurAmount&quot;, 1.0f - blurAmount);            Graphics.Blit (src, accumulationTexture, material);            Graphics.Blit (accumulationTexture, dest);        &#125; else &#123;            Graphics.Blit(src, dest);        &#125;    &#125;&#125;</code></pre><h1 id="shader"><a href="#shader" class="headerlink" title="shader"></a>shader</h1><pre><code class="lang-c">// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;Shader &quot;Unity Shaders Book/Chapter 12/Motion Blur&quot; &#123;    Properties &#123;        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;        _BlurAmount (&quot;Blur Amount&quot;, Float) = 1.0    &#125;    SubShader &#123;        CGINCLUDE        #include &quot;UnityCG.cginc&quot;        sampler2D _MainTex;        fixed _BlurAmount;        struct v2f &#123;            float4 pos : SV_POSITION;            half2 uv : TEXCOORD0;        &#125;;        v2f vert(appdata_img v) &#123;            v2f o;            o.pos = UnityObjectToClipPos(v.vertex);            o.uv = v.texcoord;            return o;        &#125;        fixed4 fragRGB (v2f i) : SV_Target &#123;            return fixed4(tex2D(_MainTex, i.uv).rgb, _BlurAmount);        &#125;        half4 fragA (v2f i) : SV_Target &#123;            return tex2D(_MainTex, i.uv);        &#125;        ENDCG        ZTest Always Cull Off ZWrite Off        Pass &#123;        //把当前图像和之前图像进行混合，混合系数是_BlurAmount            Blend SrcAlpha OneMinusSrcAlpha            ColorMask RGB            CGPROGRAM            #pragma vertex vert              #pragma fragment fragRGB              ENDCG        &#125;        Pass &#123;           //最后的a通道希望还是设置为原图像的a通过，只混合rgb            Blend One Zero            ColorMask A            CGPROGRAM              #pragma vertex vert              #pragma fragment fragA            ENDCG        &#125;    &#125;     FallBack Off&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第十二章：屏幕后处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
            <tag> unity </tag>
            
            <tag> 屏幕后处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高斯模糊</title>
      <link href="/posts/a45cef5f.html"/>
      <url>/posts/a45cef5f.html</url>
      
        <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>利用另一个算子，均值滤波器，这个算子的作用可以平均邻域内的像素，从而达到模糊的效果</p><p>高斯滤波：很好的模拟了邻域每个像素对当前像素的影响程度：距离越近，影响越大。高斯核的维数越高，模糊程度越大。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>把5x5的高斯核变成横向和纵向的两个一位高斯核，用两个pass来得到最后的图像，通过图像缩放提高性能，通过应用次数来控制模糊程度</p><p>脚本类：</p><pre><code class="lang-c#">using UnityEngine;using System.Collections;public class GaussianBlur : PostEffectsBase &#123;    public Shader gaussianBlurShader;    private Material gaussianBlurMaterial = null;    public Material material &#123;          get &#123;            gaussianBlurMaterial = CheckShaderAndCreateMaterial(gaussianBlurShader, gaussianBlurMaterial);            return gaussianBlurMaterial;        &#125;      &#125;    // Blur iterations - larger number means more blur.    //迭代次数，模糊范围，缩放系数    [Range(0, 4)]    public int iterations = 3;    // Blur spread for each iteration - larger value means more blur    [Range(0.2f, 3.0f)]    public float blurSpread = 0.6f;    [Range(1, 8)]    public int downSample = 2;    /// 1st edition: just apply blur//    void OnRenderImage(RenderTexture src, RenderTexture dest) &#123;//        if (material != null) &#123;//            int rtW = src.width;//            int rtH = src.height;//通过该函数分配了一块与屏幕图像大小相同的缓冲区，用来存放第一个pass的结果//            RenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, 0);////            // Render the vertical pass//            Graphics.Blit(src, buffer, material, 0);//            // Render the horizontal pass//            Graphics.Blit(buffer, dest, material, 1);////            RenderTexture.ReleaseTemporary(buffer);//        &#125; else &#123;//            Graphics.Blit(src, dest);//        &#125;//    &#125;     /// 2nd edition: scale the render texture//    void OnRenderImage (RenderTexture src, RenderTexture dest) &#123;//        if (material != null) //让缓冲区大小缩小，使用双线性插值，当把图片导出缓冲区的时候，多个像素归并为一个，可以减少像素数，可以提供性能的同时提供更好的模糊效果//            int rtW = src.width/downSample;//            int rtH = src.height/downSample;//            RenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, 0);//            buffer.filterMode = FilterMode.Bilinear;////            // Render the vertical pass//            Graphics.Blit(src, buffer, material, 0);//            // Render the horizontal pass//            Graphics.Blit(buffer, dest, material, 1);////            RenderTexture.ReleaseTemporary(buffer);//        &#125; else &#123;//            Graphics.Blit(src, dest);//        &#125;//    &#125;    /// 3rd edition: use iterations for larger blur    void OnRenderImage (RenderTexture src, RenderTexture dest) &#123;        if (material != null) &#123;            int rtW = src.width/downSample;            int rtH = src.height/downSample;            RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, 0);            buffer0.filterMode = FilterMode.Bilinear;            Graphics.Blit(src, buffer0);            for (int i = 0; i &lt; iterations; i++) &#123;                //每一次迭代的时候，都扩大模糊范围                material.SetFloat(&quot;_BlurSize&quot;, 1.0f + i * blurSpread);                RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0);                // Render the vertical pass                Graphics.Blit(buffer0, buffer1, material, 0);                RenderTexture.ReleaseTemporary(buffer0);                buffer0 = buffer1;                buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0);                // Render the horizontal pass                Graphics.Blit(buffer0, buffer1, material, 1);                RenderTexture.ReleaseTemporary(buffer0);                buffer0 = buffer1;            &#125;            Graphics.Blit(buffer0, dest);            RenderTexture.ReleaseTemporary(buffer0);        &#125; else &#123;            Graphics.Blit(src, dest);        &#125;    &#125;&#125;</code></pre><h1 id="shader"><a href="#shader" class="headerlink" title="shader"></a>shader</h1><pre><code class="lang-c#">// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;Shader &quot;Unity Shaders Book/Chapter 12/Gaussian Blur&quot; &#123;    Properties &#123;        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;        _BlurSize (&quot;Blur Size&quot;, Float) = 1.0    &#125;    SubShader &#123;        CGINCLUDE        #include &quot;UnityCG.cginc&quot;        sampler2D _MainTex;          half4 _MainTex_TexelSize;        float _BlurSize;        struct v2f &#123;            float4 pos : SV_POSITION;            half2 uv[5]: TEXCOORD0;        &#125;;        v2f vertBlurVertical(appdata_img v) &#123;            v2f o;            o.pos = UnityObjectToClipPos(v.vertex);            half2 uv = v.texcoord;            o.uv[0] = uv;            o.uv[1] = uv + float2(0.0, _MainTex_TexelSize.y * 1.0) * _BlurSize;            o.uv[2] = uv - float2(0.0, _MainTex_TexelSize.y * 1.0) * _BlurSize;            o.uv[3] = uv + float2(0.0, _MainTex_TexelSize.y * 2.0) * _BlurSize;            o.uv[4] = uv - float2(0.0, _MainTex_TexelSize.y * 2.0) * _BlurSize;            return o;        &#125;        v2f vertBlurHorizontal(appdata_img v) &#123;            v2f o;            o.pos = UnityObjectToClipPos(v.vertex);            half2 uv = v.texcoord;            o.uv[0] = uv;            o.uv[1] = uv + float2(_MainTex_TexelSize.x * 1.0, 0.0) * _BlurSize;            o.uv[2] = uv - float2(_MainTex_TexelSize.x * 1.0, 0.0) * _BlurSize;            o.uv[3] = uv + float2(_MainTex_TexelSize.x * 2.0, 0.0) * _BlurSize;            o.uv[4] = uv - float2(_MainTex_TexelSize.x * 2.0, 0.0) * _BlurSize;            return o;        &#125;        fixed4 fragBlur(v2f i) : SV_Target &#123;        //由于5x5，其实是对称的，所以只需要知道一边的参数值就行            float weight[3] = &#123;0.4026, 0.2442, 0.0545&#125;;            fixed3 sum = tex2D(_MainTex, i.uv[0]).rgb * weight[0];            for (int it = 1; it &lt; 3; it++) &#123;                sum += tex2D(_MainTex, i.uv[it*2-1]).rgb * weight[it];                sum += tex2D(_MainTex, i.uv[it*2]).rgb * weight[it];            &#125;            return fixed4(sum, 1.0);        &#125;        ENDCG        ZTest Always Cull Off ZWrite Off        Pass &#123;            NAME &quot;GAUSSIAN_BLUR_VERTICAL&quot;            CGPROGRAM            #pragma vertex vertBlurVertical              #pragma fragment fragBlur            ENDCG          &#125;        Pass &#123;              NAME &quot;GAUSSIAN_BLUR_HORIZONTAL&quot;            CGPROGRAM              #pragma vertex vertBlurHorizontal              #pragma fragment fragBlur            ENDCG        &#125;    &#125;     FallBack &quot;Diffuse&quot;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第十二章：屏幕后处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
            <tag> unity </tag>
            
            <tag> 屏幕后处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调整屏幕亮度 饱和度 对比度</title>
      <link href="/posts/232ee143.html"/>
      <url>/posts/232ee143.html</url>
      
        <content type="html"><![CDATA[<h1 id="为摄像机添加脚本"><a href="#为摄像机添加脚本" class="headerlink" title="为摄像机添加脚本"></a>为摄像机添加脚本</h1><pre><code class="lang-c#">using UnityEngine;using System.Collections;//该脚本继承自PostEffectsBasepublic class BrightnessSaturationAndContrast : PostEffectsBase &#123;    public Shader briSatConShader;    private Material briSatConMaterial;    //使用该shader并且返回一个使用该shader的材质    public Material material &#123;          get &#123;            briSatConMaterial = CheckShaderAndCreateMaterial(briSatConShader, briSatConMaterial);            return briSatConMaterial;        &#125;      &#125;    //定义三个参数用于调整亮度，饱和度，对比度    [Range(0.0f, 3.0f)]    public float brightness = 1.0f;    [Range(0.0f, 3.0f)]    public float saturation = 1.0f;    [Range(0.0f, 3.0f)]    public float contrast = 1.0f;    //用上面的值设置shader当中的值    void OnRenderImage(RenderTexture src, RenderTexture dest) &#123;        if (material != null) &#123;            material.SetFloat(&quot;_Brightness&quot;, brightness);            material.SetFloat(&quot;_Saturation&quot;, saturation);            material.SetFloat(&quot;_Contrast&quot;, contrast);            //调用该shader把原纹理处理后存入目标纹理            Graphics.Blit(src, dest, material);        &#125; else &#123;            Graphics.Blit(src, dest);        &#125;    &#125;&#125;</code></pre><h1 id="shader脚本"><a href="#shader脚本" class="headerlink" title="shader脚本"></a>shader脚本</h1><p><a href="https://zhuanlan.zhihu.com/p/151863284">详解RGB和HSB之间的奥秘 - 知乎 (zhihu.com)</a></p><pre><code class="lang-c#">// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;Shader &quot;Unity Shaders Book/Chapter 12/Brightness Saturation And Contrast&quot; &#123;    Properties &#123;        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Brightness (&quot;Brightness&quot;, Float) = 1        _Saturation(&quot;Saturation&quot;, Float) = 1        _Contrast(&quot;Contrast&quot;, Float) = 1    &#125;    SubShader &#123;        Pass &#123;          //关闭深度写入和背面剔除            ZTest Always Cull Off ZWrite Off            CGPROGRAM              #pragma vertex vert              #pragma fragment frag              #include &quot;UnityCG.cginc&quot;              sampler2D _MainTex;              half _Brightness;            half _Saturation;            half _Contrast;            struct v2f &#123;                float4 pos : SV_POSITION;                half2 uv: TEXCOORD0;            &#125;;            v2f vert(appdata_img v) &#123;                v2f o;                o.pos = UnityObjectToClipPos(v.vertex);                o.uv = v.texcoord;                return o;            &#125;            fixed4 frag(v2f i) : SV_Target &#123;                fixed4 renderTex = tex2D(_MainTex, i.uv);                  // Apply brightness                fixed3 finalColor = renderTex.rgb * _Brightness;                // Apply saturation                fixed luminance = 0.2125 * renderTex.r + 0.7154 * renderTex.g + 0.0721 * renderTex.b;                fixed3 luminanceColor = fixed3(luminance, luminance, luminance);                finalColor = lerp(luminanceColor, finalColor, _Saturation);                // Apply contrast                fixed3 avgColor = fixed3(0.5, 0.5, 0.5);                finalColor = lerp(avgColor, finalColor, _Contrast);                return fixed4(finalColor, renderTex.a);              &#125;              ENDCG        &#125;      &#125;    Fallback Off&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第十二章：屏幕后处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
            <tag> unity </tag>
            
            <tag> 屏幕后处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bloom</title>
      <link href="/posts/c6cd7d1b.html"/>
      <url>/posts/c6cd7d1b.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是bloom效果"><a href="#什么是bloom效果" class="headerlink" title="什么是bloom效果"></a>什么是bloom效果</h1><p>bloom：这种特效可以模拟真实摄像机的一种图像效果，可以让画面较亮的区域扩散到周围的区域，造成朦胧的效果</p><p>实现原理：根据阈值提取图像中的较亮区域，存储在一张渲染纹理中，再利用高斯模糊对这张渲染纹理进行模糊处理，模拟光线扩散的效果，最后和原图叠加。</p><h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><pre><code class="lang-c#">using UnityEngine;using System.Collections;public class Bloom : PostEffectsBase &#123;    public Shader bloomShader;    private Material bloomMaterial = null;    public Material material &#123;          get &#123;            bloomMaterial = CheckShaderAndCreateMaterial(bloomShader, bloomMaterial);            return bloomMaterial;        &#125;      &#125;    // Blur iterations - larger number means more blur.    [Range(0, 4)]    public int iterations = 3;    // Blur spread for each iteration - larger value means more blur    [Range(0.2f, 3.0f)]    public float blurSpread = 0.6f;    [Range(1, 8)]    public int downSample = 2;    //把亮度值设置在0-4区间，主要是考虑hdr的亮度有可能超过1    [Range(0.0f, 4.0f)]    public float luminanceThreshold = 0.6f;    void OnRenderImage (RenderTexture src, RenderTexture dest) &#123;        //基于高斯模糊        if (material != null) &#123;            material.SetFloat(&quot;_LuminanceThreshold&quot;, luminanceThreshold);            int rtW = src.width/downSample;            int rtH = src.height/downSample;            RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, 0);            buffer0.filterMode = FilterMode.Bilinear;            Graphics.Blit(src, buffer0, material, 0);            for (int i = 0; i &lt; iterations; i++) &#123;                material.SetFloat(&quot;_BlurSize&quot;, 1.0f + i * blurSpread);                RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0);                // Render the vertical pass                Graphics.Blit(buffer0, buffer1, material, 1);                RenderTexture.ReleaseTemporary(buffer0);                buffer0 = buffer1;                buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0);                // Render the horizontal pass                Graphics.Blit(buffer0, buffer1, material, 2);                RenderTexture.ReleaseTemporary(buffer0);                buffer0 = buffer1;            &#125;            //将模糊后的高亮部分放入到最后一个pass中处理，用来和原图叠加            material.SetTexture (&quot;_Bloom&quot;, buffer0);              Graphics.Blit (src, dest, material, 3);              RenderTexture.ReleaseTemporary(buffer0);        &#125; else &#123;            Graphics.Blit(src, dest);        &#125;    &#125;&#125;</code></pre><h1 id="shader"><a href="#shader" class="headerlink" title="shader"></a>shader</h1><pre><code class="lang-c#">// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;Shader &quot;Unity Shaders Book/Chapter 12/Bloom&quot; &#123;    Properties &#123;        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Bloom (&quot;Bloom (RGB)&quot;, 2D) = &quot;black&quot; &#123;&#125;        _LuminanceThreshold (&quot;Luminance Threshold&quot;, Float) = 0.5        _BlurSize (&quot;Blur Size&quot;, Float) = 1.0    &#125;    SubShader &#123;        CGINCLUDE        #include &quot;UnityCG.cginc&quot;        sampler2D _MainTex;        half4 _MainTex_TexelSize;        sampler2D _Bloom;        float _LuminanceThreshold;        float _BlurSize;        struct v2f &#123;            float4 pos : SV_POSITION;             half2 uv : TEXCOORD0;        &#125;;            v2f vertExtractBright(appdata_img v) &#123;            v2f o;            o.pos = UnityObjectToClipPos(v.vertex);            o.uv = v.texcoord;            return o;        &#125;        fixed luminance(fixed4 color) &#123;            return  0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b;         &#125;        fixed4 fragExtractBright(v2f i) : SV_Target &#123;            fixed4 c = tex2D(_MainTex, i.uv);            //通过阈值裁剪            fixed val = clamp(luminance(c) - _LuminanceThreshold, 0.0, 1.0);            return c * val;        &#125;        struct v2fBloom &#123;            float4 pos : SV_POSITION;             half4 uv : TEXCOORD0;        &#125;;        v2fBloom vertBloom(appdata_img v) &#123;            v2fBloom o;            o.pos = UnityObjectToClipPos (v.vertex);            o.uv.xy = v.texcoord;                    o.uv.zw = v.texcoord;            //平台差异化处理            #if UNITY_UV_STARTS_AT_TOP                        if (_MainTex_TexelSize.y &lt; 0.0)                o.uv.w = 1.0 - o.uv.w;            #endif            return o;         &#125;        fixed4 fragBloom(v2fBloom i) : SV_Target &#123;        //在片元中将两个图叠加            return tex2D(_MainTex, i.uv.xy) + tex2D(_Bloom, i.uv.zw);        &#125;         ENDCG        ZTest Always Cull Off ZWrite Off        Pass &#123;              CGPROGRAM              #pragma vertex vertExtractBright              #pragma fragment fragExtractBright              ENDCG          &#125;        UsePass &quot;Unity Shaders Book/Chapter 12/Gaussian Blur/GAUSSIAN_BLUR_VERTICAL&quot;        UsePass &quot;Unity Shaders Book/Chapter 12/Gaussian Blur/GAUSSIAN_BLUR_HORIZONTAL&quot;        Pass &#123;              CGPROGRAM              #pragma vertex vertBloom              #pragma fragment fragBloom              ENDCG          &#125;    &#125;    FallBack Off&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第十二章：屏幕后处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
            <tag> unity </tag>
            
            <tag> 屏幕后处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>边缘检测</title>
      <link href="/posts/1d0f563b.html"/>
      <url>/posts/1d0f563b.html</url>
      
        <content type="html"><![CDATA[<h1 id="图像处理中的卷积"><a href="#图像处理中的卷积" class="headerlink" title="图像处理中的卷积"></a>图像处理中的卷积</h1><p>其实就是用卷积核对一张图像的像素进行处理，不同卷积核所处理的最终效果不同。</p><p>其实也叫算子。这部分内容请自学相关内容。</p><h1 id="使用sobal算子计算边缘"><a href="#使用sobal算子计算边缘" class="headerlink" title="使用sobal算子计算边缘"></a>使用sobal算子计算边缘</h1><p>sobal算子一般是两个3x3的算子，一个用来计算上下之间的像素差，一个计算左右的像素差，像素差越大，该像素就越白或越黑。两个得到的梯度值通过平方和开根号得到最终的梯度值。</p><h1 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h1><p>其实不难看出，脚本的作用主要就是调用OnRenderImage和传入控制的参数，真正的处理需要放到shader当中。</p><pre><code class="lang-c#">//EdgeDetection.csusing UnityEngine;using System.Collections;public class EdgeDetection : PostEffectsBase &#123;    public Shader edgeDetectShader;    private Material edgeDetectMaterial = null;    public Material material &#123;          get &#123;            edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);            return edgeDetectMaterial;        &#125;      &#125;    //调整边缘性强度，描边颜色，以及背景颜色    [Range(0.0f, 1.0f)]    public float edgesOnly = 0.0f;    public Color edgeColor = Color.black;    public Color backgroundColor = Color.white;    void OnRenderImage (RenderTexture src, RenderTexture dest) &#123;        if (material != null) &#123;            material.SetFloat(&quot;_EdgeOnly&quot;, edgesOnly);            material.SetColor(&quot;_EdgeColor&quot;, edgeColor);            material.SetColor(&quot;_BackgroundColor&quot;, backgroundColor);            Graphics.Blit(src, dest, material);        &#125; else &#123;            Graphics.Blit(src, dest);        &#125;    &#125;&#125;</code></pre><h1 id="shader编写"><a href="#shader编写" class="headerlink" title="shader编写"></a>shader编写</h1><pre><code class="lang-c#">// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;Shader &quot;Unity Shaders Book/Chapter 12/Edge Detection&quot; &#123;    Properties &#123;        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;        _EdgeOnly (&quot;Edge Only&quot;, Float) = 1.0        _EdgeColor (&quot;Edge Color&quot;, Color) = (0, 0, 0, 1)        _BackgroundColor (&quot;Background Color&quot;, Color) = (1, 1, 1, 1)    &#125;    SubShader &#123;        Pass &#123;              ZTest Always Cull Off ZWrite Off            CGPROGRAM            #include &quot;UnityCG.cginc&quot;            #pragma vertex vert              #pragma fragment fragSobel            sampler2D _MainTex;              uniform half4 _MainTex_TexelSize;            fixed _EdgeOnly;            fixed4 _EdgeColor;            fixed4 _BackgroundColor;            struct v2f &#123;                float4 pos : SV_POSITION;                half2 uv[9] : TEXCOORD0;            &#125;;            v2f vert(appdata_img v) &#123;                v2f o;                o.pos = UnityObjectToClipPos(v.vertex);                half2 uv = v.texcoord;                //计算一个3x3范围的uv坐标                o.uv[0] = uv + _MainTex_TexelSize.xy * half2(-1, -1);                o.uv[1] = uv + _MainTex_TexelSize.xy * half2(0, -1);                o.uv[2] = uv + _MainTex_TexelSize.xy * half2(1, -1);                o.uv[3] = uv + _MainTex_TexelSize.xy * half2(-1, 0);                o.uv[4] = uv + _MainTex_TexelSize.xy * half2(0, 0);                o.uv[5] = uv + _MainTex_TexelSize.xy * half2(1, 0);                o.uv[6] = uv + _MainTex_TexelSize.xy * half2(-1, 1);                o.uv[7] = uv + _MainTex_TexelSize.xy * half2(0, 1);                o.uv[8] = uv + _MainTex_TexelSize.xy * half2(1, 1);                return o;            &#125;            fixed luminance(fixed4 color) &#123;                return  0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b;             &#125;            half Sobel(v2f i) &#123;                const half Gx[9] = &#123;-1,  0,  1,                                        -2,  0,  2,                                        -1,  0,  1&#125;;                const half Gy[9] = &#123;-1, -2, -1,                                        0,  0,  0,                                        1,  2,  1&#125;;                        half texColor;                half edgeX = 0;                half edgeY = 0;                for (int it = 0; it &lt; 9; it++) &#123;                    texColor = luminance(tex2D(_MainTex, i.uv[it]));                    edgeX += texColor * Gx[it];                    edgeY += texColor * Gy[it];                &#125;                //两个绝对值相加，其实就是梯度值越大，值越大，用1减去该值，就说明edge越小，梯度越大                half edge = 1 - abs(edgeX) - abs(edgeY);                return edge;            &#125;            fixed4 fragSobel(v2f i) : SV_Target &#123;                half edge = Sobel(i);                //这里的lerp函数是(1-edge)*y1+edge*y2,所以edge越小（梯度越大）,值越接近边缘线的颜色。                fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[4]), edge);                //这里把背景颜色和边缘线颜色插值，edge越小，边缘线越明显                fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);                //再插值，其实我感觉就是显示原像素还是显示背景颜色了，其实就是控制背景的影响效果                return lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);             &#125;            ENDCG        &#125;     &#125;    FallBack Off&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第十二章：屏幕后处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
            <tag> unity </tag>
            
            <tag> 屏幕后处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.1 UnityShader概述</title>
      <link href="/posts/d872e91.html"/>
      <url>/posts/d872e91.html</url>
      
        <content type="html"><![CDATA[<h1 id="ShaderLab"><a href="#ShaderLab" class="headerlink" title="ShaderLab"></a>ShaderLab</h1><p>* </p>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第三章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.6 小心平台差异</title>
      <link href="/posts/9805665e.html"/>
      <url>/posts/9805665e.html</url>
      
        <content type="html"><![CDATA[<h1 id="渲染纹理的坐标差异"><a href="#渲染纹理的坐标差异" class="headerlink" title="渲染纹理的坐标差异"></a>渲染纹理的坐标差异</h1><p>前提：我们需要使用渲染纹理（render texture）保存渲染结果时，就要注意openGL和DirectX的差异</p><p>结果：unity会在背后帮助处理，以达到不同平台的一致性</p><p>特殊情况：开启抗锯齿后（edit-project settings-quality-anti alising）,碰到具体问题时再详细了解（p115-p116）</p><h1 id="shader-的语法差异"><a href="#shader-的语法差异" class="headerlink" title="shader 的语法差异"></a>shader 的语法差异</h1><h1 id="shader的语义差异"><a href="#shader的语义差异" class="headerlink" title="shader的语义差异"></a>shader的语义差异</h1>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第五章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渲染平台差异 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1.2 什么是渲染流水线</title>
      <link href="/posts/b4510626.html"/>
      <url>/posts/b4510626.html</url>
      
        <content type="html"><![CDATA[<h1 id="渲染流水线"><a href="#渲染流水线" class="headerlink" title="渲染流水线"></a>渲染流水线</h1><p>工作任务：将三维场景渲染（生成）为一张二维图像。</p><ul><li><p>渲染流程：</p><ol><li><p>应用阶段(Application)：开发者决定</p><ul><li>准备场景数据（模型，相机，光源等）</li><li>culling，剔除不可见物体</li><li>设置渲染状态（材质，纹理，shader）</li><li>输出渲染图元（几何信息）</li></ul></li><li><p>几何阶段(Geometry)：GPU上</p><ul><li>绘制什么</li><li>如何绘制</li><li>在哪绘制</li></ul><p>把顶点坐标变换到屏幕空间，输出屏幕空间的二维顶点坐标，深度值，着色等信息。</p></li><li><p>光栅化阶段(Rasterizer)：GPU</p><ul><li>根据数据渲染最终图像</li><li>像素化（个人理解）</li></ul></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第二章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渲染流水线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.5 什么是shader</title>
      <link href="/posts/945c8b95.html"/>
      <url>/posts/945c8b95.html</url>
      
        <content type="html"><![CDATA[<h1 id="Shader究竟是什么"><a href="#Shader究竟是什么" class="headerlink" title="Shader究竟是什么"></a>Shader究竟是什么</h1><ul><li>GPU流水线上高度可编程的阶段</li><li>重点是顶点着色器控制顶点变换和传递数据，片元着色器进行逐片元的渲染。S</li></ul>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第二章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渲染流水线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.2 应用阶段</title>
      <link href="/posts/ec3c3a35.html"/>
      <url>/posts/ec3c3a35.html</url>
      
        <content type="html"><![CDATA[<h1 id="CPU和GPU的通讯（应用阶段）"><a href="#CPU和GPU的通讯（应用阶段）" class="headerlink" title="CPU和GPU的通讯（应用阶段）"></a>CPU和GPU的通讯（应用阶段）</h1><h2 id="把数据加载到显存"><a href="#把数据加载到显存" class="headerlink" title="把数据加载到显存"></a>把数据加载到显存</h2><ol><li>数据从硬盘加载到系统内存（RAM）</li><li>RAM把数据加载到显卡显存上：<ul><li>显卡对显存访问更快</li><li>大多数显卡没有RAM的直接访问权利</li></ul></li></ol><h2 id="设置渲染状态"><a href="#设置渲染状态" class="headerlink" title="设置渲染状态"></a>设置渲染状态</h2><p>什么是渲染状态？<br>答：这些状态定义了网格是如何被渲染（形状，颜色，材质等属性）</p><h2 id="调用Draw-Call（渲染命令）"><a href="#调用Draw-Call（渲染命令）" class="headerlink" title="调用Draw Call（渲染命令）"></a>调用Draw Call（渲染命令）</h2><ol><li>发起方：CPU。接受方：GPU</li><li>指向一个需要被渲染的图元（primitives）列表</li><li>GPU收到指令后，会根据渲染状态渲染所指定的图元列表</li><li>渲染所需的计算过程为<strong>GPU流水线</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第二章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渲染流水线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.3 GPU流水线</title>
      <link href="/posts/aacc2f5b.html"/>
      <url>/posts/aacc2f5b.html</url>
      
        <content type="html"><![CDATA[<h1 id="GPU流水线"><a href="#GPU流水线" class="headerlink" title="GPU流水线"></a>GPU流水线</h1><p>说人话：几何阶段+光栅化阶</p><p><img src="https://gitee.com/yurain11/drawing-bed/raw/master/img/image-20230401140240022.png" alt="image-20230401140240022"></p><h2 id="几何阶段"><a href="#几何阶段" class="headerlink" title="几何阶段"></a>几何阶段</h2><ol><li><p>顶点着色器</p><p>vertex shader:完全可编程。实现顶点的空间变换，顶点着色。</p></li><li><p>曲面细分着色器</p><p>Tessellation Shader:可选着色器。用于细分图元</p></li><li><p>几何着色器</p><p>Geometry Shader:可选着色器。用于执行逐图元的着色操作，或产生更多图元。</p></li><li><p>裁剪</p><p>clipping:可配置。裁剪掉不在摄像机视野内的顶点和剔除某些面片</p><p>针对对象：部分在视野内的图元（不可编程，但可以自定一个裁剪操作）</p></li><li><p>屏幕映射</p><p>screen mapping:不可配置和编程的。用于把每个图元的坐标转换到屏幕坐标系当中。</p><p>输入：三维坐标（范围在单位正方体：即经过正交投影后的三维坐标）</p><p>需要注意OpenGL和DirectX屏幕坐标系的不同：OpenGL在左下，DirectX在左上。</p></li></ol><h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><p>输入：CPU</p><p>处理单位：顶点（每个顶点调用一次顶点着色器）</p><p>限制：无法创建和销毁顶点，无法获得两个顶点的相关联系（逐顶点计算）</p><p>优点：处理速度快（不用考虑关联性，GPU狂喜）</p><p>工作：</p><ul><li>坐标变换：<strong>把顶点坐标从模型空间转换到齐次裁剪空间</strong>，以及其他需求所需的顶点变换。</li><li>逐顶点光照</li></ul><h2 id="光栅化阶段"><a href="#光栅化阶段" class="headerlink" title="光栅化阶段"></a>光栅化阶段</h2><ol><li><p>三角形设置</p><p>输入：顶点</p><p>输出：顶点所构成的边的表示方式（三角形框）</p></li><li><p>三角形遍历Triangle Traversal（扫描变化）</p><p>工作：检查每个像素是否被三角所覆盖</p><p>输出：片元（包含被覆盖的像素，以及屏幕坐标，深度信息，法线，纹理坐标等等）而不仅仅是一个像素。</p></li><li><p>片元着色器Fragment Shader（像素着色器Pixel Shader）</p></li><li><p>逐片元操作Per-Fragment Operations(输出合并阶段Output-Merger)</p></li></ol><h3 id="片元着色器"><a href="#片元着色器" class="headerlink" title="片元着色器"></a>片元着色器</h3><p>输入：对顶点信息进行插值的像素信息（对顶点着色器输出的信息插值）</p><p>输出：一个或者多个颜色值</p><p>使用包括：纹理采样。通过对顶点纹理坐标的插值，就可以或者中间信息的纹理坐标。</p><p>局限：只正对单个片元，无法将结果传输给其他片元。</p><h3 id="逐片元操作：高度可配置性"><a href="#逐片元操作：高度可配置性" class="headerlink" title="逐片元操作：高度可配置性"></a>逐片元操作：高度可配置性</h3><p>任务：</p><ul><li>决定片元的可见性</li><li>对通过所有测试的片元的颜色值和储存在颜色缓冲区的颜色合并</li></ul><p>过程：</p><ol><li><p>模板测试Stencil test</p><p>读取片元模板值,将该值和预定值比较，比较条件自己定义，不符合条件则舍弃。一般用来限制渲染区域。（渲染阴影，轮廓渲染）</p></li><li><p>深度测试</p><p>深度就是指离屏幕的远近。根据深度值的选取条件，就可以实现基本的遮挡，以及进阶的透明等效果。也是高度自定义的。</p><p>一般来说在unity中深度测试会放在片元着色前（Early-Z）,避免着色器计算不需要的颜色。（但是在透明情况下需要关闭）</p></li><li><p>混合</p><p>关闭混合：直接覆盖颜色缓冲区的值</p><p>开启混合：可以定义混合条件，达到不同的颜色混合效果，就是PS里面的图层叠加方式（正片叠底等）</p></li><li><p>双重缓冲：保证画面连续（交替显示（避免出现渲染一半的画面））</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> unity shader 入门精要总结 </category>
          
          <category> 第二章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渲染流水线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156.html"/>
      <url>/posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="lang-bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="lang-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="lang-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="lang-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
